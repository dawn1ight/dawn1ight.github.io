<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PatriotCTF 2024 Crypto Writeup</title>
      <link href="/post/11600/"/>
      <url>/post/11600/</url>
      
        <content type="html"><![CDATA[<h2 id="patriotctf-2024-crypto-writeup">PatriotCTF 2024 Crypto Writeup</h2><p>Author: <em>dawn1ight</em></p><p>About: PatriotCTF is a beginner-friendly capture-the-flag competition hosted by GMU’s cybersecurity club, MasonCC. All are welcome to participate, including students and security professionals. Challenges will range from beginner to expert, so there should be something for everyone. This is a jeopardy-style CTF, meaning there will be various challenges from the different categories described below.</p><p>Challenges：<a href="https://pctf.competitivecyber.club/challenges">https://pctf.competitivecyber.club/challenges</a></p><p>Reference:</p><ul><li><a href="https://blog.csdn.net/weixin_52640415/article/details/142500402">https://blog.csdn.net/weixin_52640415/article/details/142500402</a></li><li><a href="https://www.ctfiot.com/206569.html">https://www.ctfiot.com/206569.html</a></li><li><a href="https://s19ma.github.io/posts/PatriotCTF/">https://s19ma.github.io/posts/PatriotCTF/</a></li></ul><h3 id="1-bigger-is-better">1. Bigger is Better</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">0xa0d9f425fe1246c25b8c3708b9f6d7747dd5b5e7f79719831c5cbe19fb7bab66ed62719b3fc6090120d2cfe1410583190cd650c32a4151550732b0fc97130e5f02aa26cb829600b6ab452b5b11373ec69d4eaae6c392d92da8bcbea85344af9d4699e36fdca075d33f58049fd0a9f6919f3003512a261a00985dc3d9843a822974df30b81732a91ce706c44bde5ff48491a45a5fa8d5d73bba5022af803ab7bd85250e71fc0254fcf078d21eaa5d38724014a85f679e8a7a1aad6ed22602465f90e6dd8ef95df287628832850af7e3628ad09ff90a6dbdf7a0e6d74f508d2a6235d4eae5a828ac95558bbdf72f39af5641dfe3edb0cdaab362805d926106e2af</span></span><br><span class="line">e = <span class="number">0x5af5dbe4af4005564908a094e0eabb0a921b7482483a753e2a4d560700cb2b2dc9399b608334e05140f54d90fcbef70cec097e3f75395d0c4799d9ec3e670aca41da0892a7b3d038acb7a518be1ced8d5224354ce39e465450c12be653639a8215afb1ba70b1f8f71fc1a0549853998e2337604fca7edac67dd1e7ddeb897308ebf26ade781710e6a2fe4c533a584566ea42068d0452c1b1ecef00a781b6d31fbab893de0c9e46fce69c71cefad3119e8ceebdab25726a96aaf02a7c4a6a38d2f75f413f89064fef14fbd5762599ca8eb3737122374c5e34a7422ea1b3d7c43a110d3209e1c5e23e4eece9e964da2c447c9e5e1c8a6038dc52d699f9324fd6b9</span></span><br><span class="line">c = <span class="number">0x731ceb0ac8f10c8ff82450b61b414c4f7265ccf9f73b8e238cc7265f83c635575a9381aa625044bde7b34ad7cce901fe7512c934b7f6729584d2a77c47e8422c8c0fe2d3dd12aceda8ef904ad5896b971f8b79048e3e2f99f600bf6bac6cad32f922899c00fdc2d21fcf3d0093216bfc5829f02c08ba5e534379cc9118c347763567251c0fe57c92efe0a96c8595bac2c759837211aac914ea3b62aae096ebb8cb384c481b086e660f0c6249c9574289fe91b683609154c066de7a94eafa749c9e92d83a9d473cc88accd9d4c5754ccdbc5aa77ba9a790bc512404a81fc566df42b652a55b9b8ffb189f734d1c007b6cbdb67e14399182016843e27e6d4e5fca</span></span><br></pre></td></tr></table></figure><p>大加密指数e，经典wiener攻击</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> RSAwienerHacker.RSAwienerHacker <span class="keyword">import</span> hack_RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">n = <span class="number">0xa0d9f425fe1246c25b8c3708b9f6d7747dd5b5e7f79719831c5cbe19fb7bab66ed62719b3fc6090120d2cfe1410583190cd650c32a4151550732b0fc97130e5f02aa26cb829600b6ab452b5b11373ec69d4eaae6c392d92da8bcbea85344af9d4699e36fdca075d33f58049fd0a9f6919f3003512a261a00985dc3d9843a822974df30b81732a91ce706c44bde5ff48491a45a5fa8d5d73bba5022af803ab7bd85250e71fc0254fcf078d21eaa5d38724014a85f679e8a7a1aad6ed22602465f90e6dd8ef95df287628832850af7e3628ad09ff90a6dbdf7a0e6d74f508d2a6235d4eae5a828ac95558bbdf72f39af5641dfe3edb0cdaab362805d926106e2af</span></span><br><span class="line">e = <span class="number">0x5af5dbe4af4005564908a094e0eabb0a921b7482483a753e2a4d560700cb2b2dc9399b608334e05140f54d90fcbef70cec097e3f75395d0c4799d9ec3e670aca41da0892a7b3d038acb7a518be1ced8d5224354ce39e465450c12be653639a8215afb1ba70b1f8f71fc1a0549853998e2337604fca7edac67dd1e7ddeb897308ebf26ade781710e6a2fe4c533a584566ea42068d0452c1b1ecef00a781b6d31fbab893de0c9e46fce69c71cefad3119e8ceebdab25726a96aaf02a7c4a6a38d2f75f413f89064fef14fbd5762599ca8eb3737122374c5e34a7422ea1b3d7c43a110d3209e1c5e23e4eece9e964da2c447c9e5e1c8a6038dc52d699f9324fd6b9</span></span><br><span class="line">c = <span class="number">0x731ceb0ac8f10c8ff82450b61b414c4f7265ccf9f73b8e238cc7265f83c635575a9381aa625044bde7b34ad7cce901fe7512c934b7f6729584d2a77c47e8422c8c0fe2d3dd12aceda8ef904ad5896b971f8b79048e3e2f99f600bf6bac6cad32f922899c00fdc2d21fcf3d0093216bfc5829f02c08ba5e534379cc9118c347763567251c0fe57c92efe0a96c8595bac2c759837211aac914ea3b62aae096ebb8cb384c481b086e660f0c6249c9574289fe91b683609154c066de7a94eafa749c9e92d83a9d473cc88accd9d4c5754ccdbc5aa77ba9a790bc512404a81fc566df42b652a55b9b8ffb189f734d1c007b6cbdb67e14399182016843e27e6d4e5fca</span></span><br><span class="line">d = hack_RSA(e,n)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="2-idk-cipher">2. idk cipher</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">********************************************</span></span><br><span class="line"><span class="string">*                                          *</span></span><br><span class="line"><span class="string">*                                          *</span></span><br><span class="line"><span class="string">********************************************</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># WARNING: This is a secret key. Do not expose it.</span></span><br><span class="line">srt_key = <span class="string">&#x27;secretkey&#x27;</span> <span class="comment"># // <span class="doctag">TODO:</span> change the placeholder</span></span><br><span class="line">usr_input = <span class="built_in">input</span>(<span class="string">&quot;\t:&quot;</span>*<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(usr_input) &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;PT must be greater than 1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(usr_input) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;PT can only be an even number&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> usr_input.isalnum():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Only alphabets and numbers supported&quot;</span>)</span><br><span class="line"><span class="comment"># WARNING: Reversing input might expose sensitive information.</span></span><br><span class="line">rsv_input = usr_input[::-<span class="number">1</span>]</span><br><span class="line">output_arr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">len</span>(usr_input) / <span class="number">2</span>)):</span><br><span class="line">    c1 = <span class="built_in">ord</span>(usr_input[i])</span><br><span class="line">    c2 = <span class="built_in">ord</span>(rsv_input[i])</span><br><span class="line">    enc_p1 = <span class="built_in">chr</span>(c1 ^ <span class="built_in">ord</span>(srt_key[i % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    enc_p2 = <span class="built_in">chr</span>(c2 ^ <span class="built_in">ord</span>(srt_key[i % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    output_arr.append(enc_p1)</span><br><span class="line">    output_arr.append(enc_p2)</span><br><span class="line"><span class="comment"># WARNING: Encoded text should not be decoded without proper authorization.</span></span><br><span class="line">encoded_val = <span class="string">&#x27;&#x27;</span>.join(output_arr)</span><br><span class="line">b64_enc_val = base64.b64encode(encoded_val.encode())</span><br><span class="line">R = <span class="string">&quot;R&quot;</span>*<span class="number">20</span></span><br><span class="line">E = <span class="string">&quot;E&quot;</span>*<span class="number">5</span></span><br><span class="line">EXCLAMATION = <span class="string">&quot;!&quot;</span>*<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ULTRA SUPE<span class="subst">&#123;R&#125;</span> SECUR<span class="subst">&#123;E&#125;</span> Encoded Cipher Text<span class="subst">&#123;EXCLAMATION&#125;</span>:&quot;</span>, b64_enc_val.decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串加密，对加密脚本逆向可得解密脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">srt_key = <span class="string">&#x27;secretkey&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设这是从上面的加密脚本中得到的Base64编码的字符串</span></span><br><span class="line">b64_enc_val = <span class="string">&quot;QRVWUFdWEUpdXEVGCF8DVEoYEEIBBlEAE0dQAURFD1I=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码Base64字符串</span></span><br><span class="line">encoded_val = base64.b64decode(b64_enc_val).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密过程</span></span><br><span class="line">decoded_arr1 = []</span><br><span class="line">decoded_arr2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encoded_val), <span class="number">2</span>):</span><br><span class="line">    c1 = <span class="built_in">ord</span>(encoded_val[i])</span><br><span class="line">    c2 = <span class="built_in">ord</span>(encoded_val[i + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用相同的密钥对字符进行异或操作</span></span><br><span class="line">    dec_p1 = <span class="built_in">chr</span>(c1 ^ <span class="built_in">ord</span>(srt_key[i // <span class="number">2</span> % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    dec_p2 = <span class="built_in">chr</span>(c2 ^ <span class="built_in">ord</span>(srt_key[i // <span class="number">2</span> % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加解密后的字符到数组中</span></span><br><span class="line">    decoded_arr1.append(dec_p1)</span><br><span class="line">    decoded_arr2.append(dec_p2)</span><br><span class="line"></span><br><span class="line">first_half = decoded_arr1</span><br><span class="line">second_half = decoded_arr2[::-<span class="number">1</span>]  <span class="comment"># 反转第二部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两部分得到最终解密结果</span></span><br><span class="line">usr_input = <span class="string">&#x27;&#x27;</span>.join(first_half + second_half)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Input:&quot;</span>, usr_input)</span><br></pre></td></tr></table></figure><h3 id="3-high-roller">3. High Roller</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3.10</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">random.seed(<span class="built_in">int</span>(time.time()))</span><br><span class="line">p, q = getPrime(<span class="number">512</span>, random.randbytes), getPrime(<span class="number">512</span>, random.randbytes)</span><br><span class="line">n = p*q</span><br><span class="line">e = getPrime(<span class="number">512</span>)</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> GCD(e, phi) == <span class="number">1</span></span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line"></span><br><span class="line">key = RSA.construct((n, e, d, p, q))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;public_key.pem&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(key.publickey().export_key(<span class="string">&quot;PEM&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;private_key.pem&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(key.export_key(<span class="string">&quot;PEM&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIHdMA0GCSqGSIb3DQEBAQUAA4HLADCBxwKBgQCMdauT2revYJrutp7eqQfrMkse</span><br><span class="line">TqfgRdLlMddaVRxiG04qJneVtpzkeLQTZqniJWx5YsUwMDeISeQjmVkr2a+Ob9S8</span><br><span class="line">+xsqVQ0XTW3xPjwKaZhW8jXAlX13ClhAxk1FvPbl6ASsPGUMX6gRSXArRYFx3Kev</span><br><span class="line">C9xng/ZKEhsC5FzBBwJBALKsZCm9FGHXvyJChFDt7vDZUCyU1jbOgS9EhNz+HrrU</span><br><span class="line">K9OCgOoZGfcjIHAcrM+w4AdF48NQELqttmKlcko6ock=</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>openssl读取公钥</p><p><code>openssl rsa -pubin -in public.pem</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">9357885447383373532894895505085381556066479232870333782284357317530689434635519527644215046975239651802146048650000941858355721661518511867620441456288201</span></span><br><span class="line">n = <span class="number">98634120039089098694716541094010585689286433311349526663366541706397717606400616707193452046001090589663396231287196347120718771479123852243352063594083947086372781079441835003204477521976780690108126553882967223715412003897334440698277808850595475155858935951484345749354296015842014107721137899755292901639</span></span><br></pre></td></tr></table></figure><p>提取出了n,e，但分解不出来</p><p>注意到<code>random.seed(int(time.time()))</code></p><blockquote><p>The seed was used is <code>int(time.time())</code> and converted into .pem file so we can use command to find time</p><p>给了公钥和p,q的生成方法，是用时间作种子，求利用random来求的。根据题目文件的时间向前可以爆破出来。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stat -c &#x27;%n %y&#x27; public_key.pem</span><br></pre></td></tr></table></figure><p>看这里复习一下stat命令 <a href="https://blog.csdn.net/u012294618/article/details/72630092">https://blog.csdn.net/u012294618/article/details/72630092</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pubkey = RSA.import_key(<span class="built_in">open</span>(<span class="string">&quot;public_key.pem&quot;</span>, <span class="string">&quot;r&quot;</span>).read())</span><br><span class="line">c = bytes_to_long(<span class="built_in">open</span>(<span class="string">&quot;flag.enc&quot;</span>, <span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">time_i = <span class="built_in">int</span>(time.mktime((<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(time_i, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    random.seed(i)</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>, random.randbytes), getPrime(<span class="number">512</span>, random.randbytes)</span><br><span class="line">    <span class="keyword">if</span> p*q == pubkey.n:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">pow</span>(pubkey.e, -<span class="number">1</span>, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, pubkey.n)))</span><br></pre></td></tr></table></figure><h3 id="4-textbook-schnorr-right">4. Textbook Schnorr right??</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EllipticCurveCrypto</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Elliptic Curve Cryptography using the secp256k1 curve.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.p = [&lt;REDACTED&gt;]</span><br><span class="line">        self.q = [&lt;REDACTED&gt;]</span><br><span class="line">        self.K = GF(self.p)</span><br><span class="line">        self.a = self.K([&lt;REDACTED&gt;])</span><br><span class="line">        self.b = self.K([&lt;REDACTED&gt;])</span><br><span class="line">        self.curve = EllipticCurve(self.K, [self.a, self.b])</span><br><span class="line">        self.generator = self.curve(</span><br><span class="line">            [&lt;REDACTED&gt;],</span><br><span class="line">            [&lt;REDACTED&gt;],</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># Generate private and public keys</span></span><br><span class="line">        self.private_key = secrets.randbelow(self.q)</span><br><span class="line">        self.public_key = self.private_key * self.generator</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Public Key: <span class="subst">&#123;self.public_key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bytes_to_int</span>(<span class="params">b</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(b, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">int_to_bytes</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">return</span> i.to_bytes((i.bit_length() + <span class="number">7</span>) // <span class="number">8</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_hash</span>(<span class="params">self, target</span>):</span><br><span class="line">        hash_int = <span class="built_in">int</span>(hashlib.sha256(<span class="built_in">str</span>(target).encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> hash_int % self.q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, message</span>):</span><br><span class="line">        r = secrets.randbelow(self.q)</span><br><span class="line">        R = r * self.generator</span><br><span class="line">        R_int = <span class="built_in">int</span>(R.xy()[<span class="number">0</span>] + R.xy()[<span class="number">1</span>])</span><br><span class="line">        h = self.compute_hash(R_int | message)</span><br><span class="line">        s = (r + self.private_key * h) % self.q</span><br><span class="line">        <span class="keyword">return</span> s, R</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, message, signature</span>):</span><br><span class="line">        s, R = signature</span><br><span class="line">        R_int = <span class="built_in">int</span>(R.xy()[<span class="number">0</span>] + R.xy()[<span class="number">1</span>])</span><br><span class="line">        h = self.compute_hash(R_int | message)</span><br><span class="line">        left_side = s * self.generator</span><br><span class="line">        right_side = R + h * self.public_key</span><br><span class="line">        <span class="keyword">return</span> left_side == right_side</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeoutInput</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeoutError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Custom exception for input timeout.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timeout_handler</span>(<span class="params">signum, frame</span>):</span><br><span class="line">        <span class="keyword">raise</span> TimeoutInput.TimeoutError(<span class="string">&quot;Input timed out!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_input</span>(<span class="params">prompt, timeout=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get user input with a timeout.</span></span><br><span class="line"><span class="string">        :param prompt: The prompt to display to the user.</span></span><br><span class="line"><span class="string">        :param timeout: The time limit for input in seconds.</span></span><br><span class="line"><span class="string">        :return: The user&#x27;s input as a string.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Set the signal for a timeout</span></span><br><span class="line">        signal.signal(signal.SIGALRM, TimeoutInput.timeout_handler)</span><br><span class="line">        signal.alarm(timeout)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user_input = <span class="built_in">input</span>(prompt)</span><br><span class="line">            signal.alarm(<span class="number">0</span>)  <span class="comment"># Cancel the timer</span></span><br><span class="line">            <span class="keyword">return</span> user_input</span><br><span class="line">        <span class="keyword">except</span> TimeoutInput.TimeoutError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No input received within the time limit.&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_flag</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read and display the flag from the &#x27;flag.txt&#x27; file.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            flag = f.read().strip()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Congratulations! Your flag is: <span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Flag file not found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_message</span>(<span class="params">separator, words, signature, ecc_instance</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Verify the provided signature for the message constructed from words and separator.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    message_bytes = separator.join(word.encode() <span class="keyword">for</span> word <span class="keyword">in</span> words) + separator</span><br><span class="line">    message_int = <span class="built_in">int</span>.from_bytes(message_bytes, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> ecc_instance.verify(message_int, signature):</span><br><span class="line">        display_flag()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Verification failed.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Initialize the elliptic curve cryptography instance</span></span><br><span class="line">    ecc = EllipticCurveCrypto()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Test the signing and verification process</span></span><br><span class="line">    test_message = ecc.bytes_to_int(<span class="string">&quot;test&quot;</span>.encode())</span><br><span class="line">    s_test, R_test = ecc.sign(test_message)</span><br><span class="line">    <span class="keyword">assert</span> ecc.verify(test_message, (s_test, R_test))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Regular expression patterns for input validation</span></span><br><span class="line">    separator_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^[0-9a-fA-F]&#123;2&#125;$&#x27;</span>)</span><br><span class="line">    word_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^[0-9a-fA-F]&#123;6&#125;$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get separator input</span></span><br><span class="line">    separator_hex = TimeoutInput.get_input(<span class="string">&quot;Enter separator as a hex value (2 digits): &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> separator_pattern.<span class="keyword">match</span>(separator_hex):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid separator format.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    separator = <span class="built_in">bytes</span>.fromhex(separator_hex)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get words input</span></span><br><span class="line">    words_hex = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        prompt = <span class="string">f&quot;Enter 3-letter word <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> as a hex value (6 digits): &quot;</span></span><br><span class="line">        word_hex = TimeoutInput.get_input(prompt)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word_pattern.<span class="keyword">match</span>(word_hex):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Invalid word format.&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        words_hex.append(word_hex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        words = [<span class="built_in">bytes</span>.fromhex(word_hex).decode(<span class="string">&#x27;ascii&#x27;</span>) <span class="keyword">for</span> word_hex <span class="keyword">in</span> words_hex]</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid ASCII encoding in words.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>(<span class="built_in">len</span>(word) != <span class="number">3</span> <span class="keyword">for</span> word <span class="keyword">in</span> words):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Words must be 3-letter ASCII words.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get signature components</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        hex_x_R = <span class="built_in">input</span>(<span class="string">&quot;Enter the x-coordinate of signature R (in hex): &quot;</span>)</span><br><span class="line">        x_R = <span class="built_in">int</span>(hex_x_R, <span class="number">16</span>)</span><br><span class="line">        hex_y_R = <span class="built_in">input</span>(<span class="string">&quot;Enter the y-coordinate of signature R (in hex): &quot;</span>)</span><br><span class="line">        y_R = <span class="built_in">int</span>(hex_y_R, <span class="number">16</span>)</span><br><span class="line">        hex_signature_s = <span class="built_in">input</span>(<span class="string">&quot;Enter signature s (in hex): &quot;</span>)</span><br><span class="line">        signature_s = <span class="built_in">int</span>(hex_signature_s, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid input for signature components.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt; signature_s &lt; ecc.q):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Illegal value of s.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the point R</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        R = ecc.curve(x_R, y_R)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Point R does not lie on the curve.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Verify the message and signature</span></span><br><span class="line">    verify_message(separator, words, (signature_s, R), ecc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这个题用了schnorr-digital-signature数字签名算法</p><p>它是将经典的<a href="https://www.geeksforgeeks.org/schnorr-digital-signature/">schnorr数字签名算法</a>移到secp256k1椭圆曲线上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 经典Schnorr签名算法</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个大素数 p 和它的大素因子 q</span></span><br><span class="line">p = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000001</span>  <span class="comment"># 一个大素数</span></span><br><span class="line">q = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span>  <span class="comment"># 大素因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个原根 g</span></span><br><span class="line">g = <span class="number">2</span>  <span class="comment"># 通常选择 2 作为原根</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名者的私钥 a 和公钥 A</span></span><br><span class="line">a = random.randint(<span class="number">1</span>, q - <span class="number">1</span>)  <span class="comment"># 私钥 a</span></span><br><span class="line">A = <span class="built_in">pow</span>(g, a, p)  <span class="comment"># 公钥 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希函数 H</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_message</span>(<span class="params">message, x</span>):</span><br><span class="line">    combined = <span class="string">f&quot;<span class="subst">&#123;message&#125;</span><span class="subst">&#123;x&#125;</span>&quot;</span>.encode()</span><br><span class="line">    h = hashlib.sha256(combined).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(h, <span class="number">16</span>) % q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">message, a, g, p, q</span>):</span><br><span class="line">    r = random.randint(<span class="number">1</span>, q - <span class="number">1</span>)  <span class="comment"># 随机数 r</span></span><br><span class="line">    X = <span class="built_in">pow</span>(g, r, p)  <span class="comment"># 计算 X</span></span><br><span class="line">    e = hash_message(message, X)  <span class="comment"># 计算 e</span></span><br><span class="line">    s = (r + a * e) % q  <span class="comment"># 计算 s</span></span><br><span class="line">    <span class="keyword">return</span> (e, s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">message, signature, A, g, p, q</span>):</span><br><span class="line">    e, s = signature</span><br><span class="line">    X_prime = (<span class="built_in">pow</span>(A, e, p) * <span class="built_in">pow</span>(g, s, p)) % p  <span class="comment"># 计算 X&#x27;</span></span><br><span class="line">    e_prime = hash_message(message, X_prime)  <span class="comment"># 计算 e&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> e_prime == e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例消息</span></span><br><span class="line">message = <span class="string">&quot;Hello, Schnorr!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名</span></span><br><span class="line">signature = sign(message, a, g, p, q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证签名</span></span><br><span class="line">is_valid = verify(message, signature, A, g, p, q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Signature is <span class="subst">&#123;<span class="string">&#x27;valid&#x27;</span> <span class="keyword">if</span> is_valid <span class="keyword">else</span> <span class="string">&#x27;invalid&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 椭圆曲线上的Schnorr签名</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 secp256k1 椭圆曲线参数</span></span><br><span class="line">p = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</span></span><br><span class="line">q = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span></span><br><span class="line">curve = EllipticCurve(GF(p), [<span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line">G = curve(<span class="number">0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</span>, <span class="number">0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">private_key = Integer(get_random_bytes(<span class="number">32</span>).<span class="built_in">hex</span>(), base=<span class="number">16</span>) % q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算公钥</span></span><br><span class="line">public_key = private_key * G</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_message</span>(<span class="params">message, x</span>):</span><br><span class="line">    combined = <span class="string">f&quot;<span class="subst">&#123;message&#125;</span><span class="subst">&#123;x&#125;</span>&quot;</span>.encode()</span><br><span class="line">    h = SHA256.new(combined).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(h, <span class="number">16</span>) % q</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">message, private_key, G, q</span>):</span><br><span class="line">    <span class="comment"># 选择随机数 r</span></span><br><span class="line">    r = Integer(get_random_bytes(<span class="number">32</span>).<span class="built_in">hex</span>(), base=<span class="number">16</span>) % q</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算点 R</span></span><br><span class="line">    R = r * G</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算挑战值 e</span></span><br><span class="line">    e = hash_message(message, R.xy()[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算签名分量 s</span></span><br><span class="line">    s = (r + e * private_key) % q</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (R.xy()[<span class="number">0</span>], s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">message, signature, public_key, G, q</span>):</span><br><span class="line">    x_R, s = signature</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算挑战值 e</span></span><br><span class="line">    e = hash_message(message, x_R)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算验证点 U</span></span><br><span class="line">    U = s * G - e * public_key</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查验证点的 x 坐标是否等于签名中的 x_R</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(U.xy()[<span class="number">0</span>]) == x_R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例消息</span></span><br><span class="line">message = <span class="string">&quot;Hello, Schnorr!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名</span></span><br><span class="line">signature = sign(message, private_key, G, q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证签名</span></span><br><span class="line">is_valid = verify(message, signature, public_key, G, q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Signature is <span class="subst">&#123;<span class="string">&#x27;valid&#x27;</span> <span class="keyword">if</span> is_valid <span class="keyword">else</span> <span class="string">&#x27;invalid&#x27;</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看出题目给出的Schnorr签名算法问题出在<code>compute_hash</code>函数上</p><p>正常的算法中<code>e = H(M||X)</code> where H() is the hash function</p><p>而题目给出的是<code>e = H(M|X)</code></p><p>所以当输入为全1时得到的hash为固定值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">separator = <span class="string">&quot;FF&quot;</span></span><br><span class="line">payload = <span class="string">&quot;7F7F7F&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Enter separator as a hex value (2 digits): &quot;</span>, separator.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 1 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 2 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 3 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 4 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 5 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 6 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 7 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 8 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line"></span><br><span class="line">TARGET = <span class="number">0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></span><br><span class="line">MESSAGE_OR_MASK = <span class="built_in">int</span>(<span class="string">&quot;7F7F7FFF&quot;</span> * <span class="number">8</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_hash</span>(<span class="params">target</span>):</span><br><span class="line">    hash_int = <span class="built_in">int</span>(hashlib.sha256(<span class="built_in">str</span>(target).encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> hash_int % n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_sig</span>(<span class="params">s, R_test</span>):</span><br><span class="line">    R_test_str = <span class="built_in">str</span>(R_test).strip(<span class="string">&quot;()&quot;</span>)</span><br><span class="line">    R_test_parts = [part.strip() <span class="keyword">for</span> part <span class="keyword">in</span> R_test_str.split(<span class="string">&quot;:&quot;</span>)]</span><br><span class="line">    xR = R_test_parts[<span class="number">0</span>]</span><br><span class="line">    yR = R_test_parts[<span class="number">1</span>]</span><br><span class="line">    sendxR = <span class="built_in">hex</span>(xR)[<span class="number">2</span>:]</span><br><span class="line">    sendyR = <span class="built_in">hex</span>(yR)[<span class="number">2</span>:]</span><br><span class="line">    send_s = <span class="built_in">hex</span>(s)[<span class="number">2</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;sendxR = &#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;sendyR = &#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;send_s = &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Enter the x-coordinate of signature R (in hex):&quot;</span>, sendxR)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Enter the y-coordinate of signature R (in hex):&quot;</span>, sendyR)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;EEnter signature s (in hex): &quot;</span>, send_s)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bruforce_signature</span>(<span class="params">P, G</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Brute-forcing to find a valid signature...&quot;</span>)</span><br><span class="line">    h = compute_hash(TARGET)</span><br><span class="line">    hP = h*P</span><br><span class="line">    s = secrets.randbelow(n)</span><br><span class="line">    sG = s*G</span><br><span class="line">    <span class="keyword">with</span> tqdm(total=<span class="number">0</span>, unit=<span class="string">&#x27; iterations&#x27;</span>, unit_scale=<span class="literal">True</span>) <span class="keyword">as</span> pbar:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            R_test = sG - hP</span><br><span class="line">            R_test_binary = <span class="built_in">int</span>(R_test.xy()[<span class="number">0</span>] + R_test.xy()[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (R_test_binary | MESSAGE_OR_MASK) == TARGET:</span><br><span class="line">                <span class="keyword">assert</span> s*G - h*P == R_test</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;found&quot;</span>)</span><br><span class="line">                verify_sig(s, R_test)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s = (s*<span class="number">2</span>) %n</span><br><span class="line">            sG = <span class="number">2</span>*sG</span><br><span class="line">            pbar.update(<span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">bruforce_signature(P, G)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WriteUP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论与编码课程实验</title>
      <link href="/post/1/"/>
      <url>/post/1/</url>
      
        <content type="html"><![CDATA[<h2 id="信源编码与信道编码综合实验">信源编码与信道编码综合实验</h2><p>实现Huffman编解码和Hamming码编解码</p><p>具体代码文件如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% a.m</span></span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&#x27;data.txt&#x27;</span>;</span><br><span class="line">[symbols, probabilities, selfinformation] = ProbabilityCalculation(file_path);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;信源符号：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(symbols);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;信源符号概率：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(probabilities);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;自信息量：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(selfinformation);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[symbols, probabilities, selfinformation]</span> = <span class="title">ProbabilityCalculation</span><span class="params">(filename)</span></span></span><br><span class="line">    <span class="comment">% 读取文件</span></span><br><span class="line">    fileID = fopen(filename, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    content = fscanf(fileID, <span class="string">&#x27;%c&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="comment">% 统计各个符号的出现次数</span></span><br><span class="line">    uniqueSymbols = unique(content);</span><br><span class="line">    symbolCounts = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(uniqueSymbols));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(uniqueSymbols)</span><br><span class="line">        symbolCounts(<span class="built_in">i</span>) = sum(content == uniqueSymbols(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 计算符号出现的概率</span></span><br><span class="line">    totalSymbols = sum(symbolCounts);</span><br><span class="line">    probabilities = symbolCounts / totalSymbols;</span><br><span class="line">    <span class="comment">% 计算自信息量</span></span><br><span class="line">    selfinformation = -<span class="built_in">log2</span>(probabilities);</span><br><span class="line">    <span class="comment">% 按照概率降序排列符号和概率</span></span><br><span class="line">    [sortedProbabilities, indices] = <span class="built_in">sort</span>(probabilities, <span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line">    symbols = uniqueSymbols(indices);</span><br><span class="line">    probabilities = sortedProbabilities;</span><br><span class="line">    <span class="comment">% 返回排序后的符号和对应的概率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% b.m</span></span><br><span class="line">[CODE, L_ave, yita, H] = HuffmanEncoding(probabilities);</span><br><span class="line"><span class="comment">% 展示输出码字、平均码长和编码效率</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;对应概率:&#x27;</span>,num2str(probabilities)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;对应码字:&#x27;</span>,CODE]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;平均码长:&#x27;</span>,num2str(L_ave)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;信源熵:&#x27;</span>,num2str(H)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;编码效率:&#x27;</span>,num2str(yita)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用新增函数进行编码并保存</span></span><br><span class="line">file_path = <span class="string">&#x27;data.txt&#x27;</span>;</span><br><span class="line">encodedFilePath = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line">decodedFilePath = <span class="string">&#x27;decoded_data.txt&#x27;</span>;</span><br><span class="line">EncodeAndSave(file_path, symbols, CODE, encodedFilePath);</span><br><span class="line">HuffmanDecoding(encodedFilePath, symbols, CODE, file_path, decodedFilePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Huffman码本对文件内容进行编码并保存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EncodeAndSave</span><span class="params">(file_path, symbols, CODE, encodedFilePath)</span></span></span><br><span class="line">    <span class="comment">% 读取原始文件内容</span></span><br><span class="line">    fileID = fopen(file_path, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    originalContent = fscanf(fileID, <span class="string">&#x27;%c&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="comment">% 初始化编码后的内容字符串</span></span><br><span class="line">    encodedContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">% 遍历原始内容的每个字符</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(originalContent)</span><br><span class="line">        <span class="comment">% 查找当前字符在symbols中的位置</span></span><br><span class="line">        symbolIndex = strfind(symbols, originalContent(<span class="built_in">i</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 如果找到，则根据索引从CODE中获取编码并添加到结果字符串</span></span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isempty</span>(symbolIndex)</span><br><span class="line">            encodedContent = strcat(encodedContent, CODE&#123;symbolIndex&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error([<span class="string">&#x27;未在符号集中找到字符：&#x27;</span>, originalContent(<span class="built_in">i</span>)]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 保存编码结果到新文件</span></span><br><span class="line">    fileID = fopen(encodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, encodedContent);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;编码内容已保存至：&#x27;</span>, encodedFilePath]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[CODE, L_ave, yita, H]</span> = <span class="title">HuffmanEncoding</span><span class="params">(probabilities)</span></span></span><br><span class="line">    p = probabilities;</span><br><span class="line">    N = <span class="built_in">length</span>(p);</span><br><span class="line">    <span class="comment">% 将概率排序并获得单步码字排序</span></span><br><span class="line">    code = strings(N<span class="number">-1</span>,N);   <span class="comment">% 初始化单步过程的码字</span></span><br><span class="line">    reflect = <span class="built_in">zeros</span>(N<span class="number">-1</span>,N);  <span class="comment">% 初始化位置对应向量</span></span><br><span class="line">    p_SD = p;                <span class="comment">% p_SD为每次得到的概率排序数组</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N<span class="number">-1</span>              <span class="comment">% i表示排序后第几个符号</span></span><br><span class="line">        M = <span class="built_in">length</span>(p_SD);</span><br><span class="line">        [p_SD,reflect(<span class="built_in">i</span>,<span class="number">1</span>:M)] = <span class="built_in">sort</span>(p_SD,<span class="string">&#x27;descend&#x27;</span>);<span class="comment">% 将概率从大到小进行排序</span></span><br><span class="line">        code(<span class="built_in">i</span>,M) = <span class="string">&#x27;1&#x27;</span>;                             <span class="comment">% 概率最小的是1</span></span><br><span class="line">        code(<span class="built_in">i</span>,M<span class="number">-1</span>) = <span class="string">&#x27;0&#x27;</span>;                           <span class="comment">% 概率第二小的暂且定义为0</span></span><br><span class="line">        p_SD(M<span class="number">-1</span>) = p_SD(M<span class="number">-1</span>) + p_SD(M);             <span class="comment">% 将最后两个概率相加</span></span><br><span class="line">        p_SD(M) = [];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 根据位置对应向量和单步过程的码字计算对应码字</span></span><br><span class="line">    CODE = strings(<span class="number">1</span>,N); <span class="comment">% 初始化对应码字</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        column = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">for</span> m = <span class="number">1</span>:N<span class="number">-1</span></span><br><span class="line">            [~, column] = <span class="built_in">find</span>(reflect(m,:) == column);</span><br><span class="line">            CODE(<span class="number">1</span>,<span class="built_in">i</span>) = strcat(CODE(<span class="number">1</span>,<span class="built_in">i</span>),code(m,column));</span><br><span class="line">            <span class="comment">% 将最小的两个概率映射成一个</span></span><br><span class="line">            <span class="keyword">if</span> column == N+<span class="number">1</span>-m</span><br><span class="line">                column = column<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    CODE = reverse(CODE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算平均码长</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">        L(<span class="built_in">i</span>) = <span class="built_in">size</span>(char(CODE(<span class="number">1</span>,<span class="built_in">i</span>)),<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    L_ave = sum(L.*p);</span><br><span class="line">    H = sum(-p.*<span class="built_in">log2</span>(p));</span><br><span class="line">    yita = H/L_ave; <span class="comment">% 计算编码效率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HuffmanDecoding</span><span class="params">(encodedFilePath, symbols, CODE, originalFilePath, decodedFilePath)</span></span></span><br><span class="line">    <span class="comment">% 读取编码后的文件内容</span></span><br><span class="line">    fileID = fopen(encodedFilePath, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    encodedContent = fscanf(fileID, <span class="string">&#x27;%s&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 构建逆码本</span></span><br><span class="line">    inv_CODE = cell(<span class="built_in">size</span>(CODE));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(CODE)</span><br><span class="line">        inv_CODE&#123;strcmp(CODE, CODE&#123;<span class="built_in">i</span>&#125;)&#125; = symbols(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 解码过程</span></span><br><span class="line">    decodedContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    currentCode = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(encodedContent)</span><br><span class="line">        currentCode = [currentCode, encodedContent(<span class="built_in">i</span>)];</span><br><span class="line">        foundSymbol = <span class="built_in">false</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">numel</span>(CODE)</span><br><span class="line">            <span class="keyword">if</span> strcmp(currentCode, CODE&#123;<span class="built_in">j</span>&#125;)</span><br><span class="line">                decodedContent = strcat(decodedContent, inv_CODE&#123;<span class="built_in">j</span>&#125;);</span><br><span class="line">                currentCode = <span class="string">&#x27;&#x27;</span>; <span class="comment">% 重置当前码，开始下一个码的匹配</span></span><br><span class="line">                foundSymbol = <span class="built_in">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 保存解码结果到新文件</span></span><br><span class="line">    fileID = fopen(decodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, decodedContent);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;解码内容已保存至：&#x27;</span>, decodedFilePath]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 与原始文件进行对比，计算误码率</span></span><br><span class="line">    originalFileContent = fileread(originalFilePath);</span><br><span class="line">    errors = sum(strcmp(decodedContent, originalFileContent) == <span class="number">0</span>);</span><br><span class="line">    totalChars = <span class="built_in">numel</span>(decodedContent);</span><br><span class="line">    errorRate = errors / totalChars;</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;误码率:&#x27;</span>, num2str(errorRate)]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% c.m</span></span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置参数</span></span><br><span class="line">n = <span class="number">7</span>;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">file_path = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取文件内容</span></span><br><span class="line">fid = fopen(file_path, <span class="string">&#x27;rt&#x27;</span>); <span class="comment">% &#x27;rt&#x27; 表示读取文本文件</span></span><br><span class="line">dataStr = fscanf(fid, <span class="string">&#x27;%c&#x27;</span>); <span class="comment">% 读取全部字符</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% 初始化二进制向量</span></span><br><span class="line">data_bits = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(dataStr));</span><br><span class="line"><span class="comment">% 遍历字符串，转换字符到比特</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(dataStr)</span><br><span class="line">    <span class="keyword">if</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;1&#x27;</span> <span class="comment">% 字符&#x27;1&#x27;转换为二进制1</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elseif</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;0&#x27;</span> <span class="comment">% 字符&#x27;0&#x27;转换为二进制0</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码解码</span></span><br><span class="line">[Encode0, Encode_str] = HammingEncoding(data_bits, n, k);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设定错误转移概率的变量范围</span></span><br><span class="line">berRange = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.1</span>; <span class="comment">% 误码率从0到10%，以0.5%为步长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化曲线数据</span></span><br><span class="line">avgBitErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(berRange));</span><br><span class="line">blockErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(berRange));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 遍历每个误码率</span></span><br><span class="line"><span class="keyword">for</span> w = <span class="number">1</span>:<span class="built_in">length</span>(berRange)</span><br><span class="line">    ber = berRange(w);</span><br><span class="line">    [Encode] = simulateBSC(Encode0, ber);</span><br><span class="line">    [Decode, Decode_str] = HammingDecoding(Encode, n, k);    </span><br><span class="line">    <span class="comment">% 计算错误位置</span></span><br><span class="line">    original_bits = data_bits; <span class="comment">% 从原始数据转换而来</span></span><br><span class="line">    decoded_bits = Decode;     <span class="comment">% 从decoded_str转换而来，确保长度一致</span></span><br><span class="line">    errors_positions = [];     <span class="comment">% 初始化错误位置列表</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(original_bits)</span><br><span class="line">        <span class="keyword">if</span> original_bits(<span class="built_in">i</span>) ~= decoded_bits(<span class="built_in">i</span>)</span><br><span class="line">            errors_positions = [errors_positions, <span class="built_in">i</span>]; <span class="comment">% 记录错误位置</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    total_errors = <span class="built_in">length</span>(errors_positions);</span><br><span class="line">    total_bits = <span class="built_in">length</span>(original_bits);</span><br><span class="line">    <span class="comment">% 计算平均误比特率</span></span><br><span class="line">    average_bit_error_rate = total_errors / total_bits;</span><br><span class="line">    <span class="comment">% 计算平均误比特率</span></span><br><span class="line">    block_error_rate = <span class="number">1</span> - (<span class="number">1</span> - average_bit_error_rate)^n;</span><br><span class="line">          </span><br><span class="line">    <span class="comment">% 记录数据</span></span><br><span class="line">    avgBitErrorRate(w) = average_bit_error_rate;</span><br><span class="line">    blockErrorRate(w) = block_error_rate;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制曲线图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制曲线图</span></span><br><span class="line"><span class="built_in">plot</span>(berRange, avgBitErrorRate, <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;Marker&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">% plot(berRange, blockErrorRate, &#x27;b-&#x27;, &#x27;LineWidth&#x27;, 2, &#x27;Marker&#x27;, &#x27;.&#x27;, &#x27;MarkerSize&#x27;, 6);</span></span><br><span class="line"><span class="comment">% 添加标题和轴标签</span></span><br><span class="line">title(<span class="string">&#x27;平均误比特率与二进制对称信道错误转移概率的关系&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;二进制对称信道错误转移概率 (BER)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;平均误比特率&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置坐标轴范围和精度</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">0.1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 可以选择设置网格线</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成矩阵和校验矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[G, H]</span> = <span class="title">hamming_code_matrices</span><span class="params">(n, k)</span></span></span><br><span class="line">    [H, G, ~, ~] = hammgen(n-k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[encoded_stream, encode_str]</span> = <span class="title">HammingEncoding</span><span class="params">(data_bits, n, k)</span></span></span><br><span class="line">    <span class="comment">% 获取生成矩阵</span></span><br><span class="line">    [G, ~] = hamming_code_matrices(n, k);</span><br><span class="line">    <span class="comment">% disp(G);</span></span><br><span class="line">    <span class="comment">% 初始化编码结果的存储</span></span><br><span class="line">    encoded_stream = [];</span><br><span class="line">    <span class="comment">% 处理整个比特流</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data_bits) &gt;= k</span><br><span class="line">        <span class="comment">% 对当前k位数据进行编码</span></span><br><span class="line">        group = data_bits(<span class="number">1</span>:k);</span><br><span class="line">        <span class="comment">% 对当前组进行编码</span></span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>); </span><br><span class="line">        <span class="comment">% 累积编码结果</span></span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group]; </span><br><span class="line">        <span class="comment">% 移动到下一个k位数据</span></span><br><span class="line">        data_bits = data_bits(k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 处理剩余不足k位的数据（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(data_bits)</span><br><span class="line">        <span class="comment">% 补齐到k位</span></span><br><span class="line">        data_bits(<span class="keyword">end</span>+<span class="number">1</span>:k) = <span class="built_in">zeros</span>(<span class="number">1</span>, k - <span class="built_in">length</span>(data_bits));</span><br><span class="line">        group = data_bits;</span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>);</span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group];</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 显示最终编码后的比特流</span></span><br><span class="line">    encode_str = num2str(encoded_stream);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 解码（有纠错）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[decoded_data, decoded_str]</span> = <span class="title">HammingDecoding</span><span class="params">(encoded_stream, n, k)</span>    </span></span><br><span class="line">    [~, H] = hamming_code_matrices(n, k);     </span><br><span class="line">    decoded_data = [];    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(encoded_stream)&gt;=n</span><br><span class="line">        encoded_group = encoded_stream(<span class="number">1</span>:n);        </span><br><span class="line">        encoded_stream = encoded_stream(n+<span class="number">1</span>:<span class="keyword">end</span>);        </span><br><span class="line">        syndrome = <span class="built_in">mod</span>(encoded_group * H&#x27;, <span class="number">2</span>);</span><br><span class="line">        mat1 = <span class="built_in">eye</span>(n);</span><br><span class="line">        errvec = mat1*H&#x27;;</span><br><span class="line">        <span class="comment">% 如果syndrome非零，则存在错误</span></span><br><span class="line">        <span class="keyword">if</span> any(syndrome)            </span><br><span class="line">            <span class="keyword">for</span> index=<span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span>(syndrome==errvec(index,:))</span><br><span class="line">                    encoded_group = <span class="built_in">mod</span>(encoded_group+mat1(index,:),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>             </span><br><span class="line">        decoded_group = encoded_group(n-k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">        <span class="comment">% 累积解码数据，不忽略任何编码组</span></span><br><span class="line">        decoded_data = [decoded_data, decoded_group];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    decoded_data = [decoded_data, encoded_stream];</span><br><span class="line">    <span class="comment">%disp([&#x27;总纠错数：&#x27;,corrected_errors]);</span></span><br><span class="line">    <span class="comment">% 转换为字符串</span></span><br><span class="line">    decoded_str = num2str(decoded_data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 二进制对称信道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[transmittedStream]</span> = <span class="title">simulateBSC</span><span class="params">(encodedStream, ber)</span></span></span><br><span class="line">    <span class="comment">% 模拟二进制对称信道传输编码后的数据流</span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">%   encodedStream: 编码后的二进制数据流，1xN的二进制数组</span></span><br><span class="line">    <span class="comment">%   ber: 误码率，一个介于0和1之间的标量</span></span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">%   transmittedStream: 通过BSC传输后的数据流</span></span><br><span class="line">    <span class="comment">% 获取数据流的长度</span></span><br><span class="line">    streamLength = <span class="built_in">length</span>(encodedStream);</span><br><span class="line">    <span class="comment">% 生成随机错误分布，1表示发生错误，0表示无错误</span></span><br><span class="line">    errorVector = <span class="built_in">rand</span>(streamLength, <span class="number">1</span>) &lt; ber;</span><br><span class="line">    <span class="comment">% 应用错误到数据流</span></span><br><span class="line">    transmittedStream = encodedStream;</span><br><span class="line">    transmittedStream(errorVector == <span class="number">1</span>) = xor(encodedStream(errorVector == <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 返回经过错误注入的传输数据流</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% d.m</span></span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置参数</span></span><br><span class="line">n = <span class="number">7</span>;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">file_path = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取文件内容</span></span><br><span class="line">fid = fopen(file_path, <span class="string">&#x27;rt&#x27;</span>); <span class="comment">% &#x27;rt&#x27; 表示读取文本文件</span></span><br><span class="line">dataStr = fscanf(fid, <span class="string">&#x27;%c&#x27;</span>);  <span class="comment">% 读取全部字符</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% 初始化二进制向量</span></span><br><span class="line">data_bits = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(dataStr));</span><br><span class="line"><span class="comment">% 遍历字符串，转换字符到比特</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(dataStr)</span><br><span class="line">    <span class="keyword">if</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;1&#x27;</span> <span class="comment">% 字符&#x27;1&#x27;转换为二进制1</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elseif</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;0&#x27;</span> <span class="comment">% 字符&#x27;0&#x27;转换为二进制0</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码解码</span></span><br><span class="line">[Encode, Encode_str] = HammingEncoding(data_bits, n, k);</span><br><span class="line">ber = <span class="number">0.001</span>; <span class="comment">% 设定误码率为0.1%</span></span><br><span class="line">[G, H] = hamming_code_matrices(n, k);</span><br><span class="line">[Encode] = simulateBSC(Encode, ber);</span><br><span class="line">[Decode, Decode_str] = HammingDecoding(Encode, n, k);</span><br><span class="line">decodedFilePath = <span class="string">&#x27;decoded.txt&#x27;</span>;</span><br><span class="line">fileID = fopen(decodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, Decode_str);</span><br><span class="line">fclose(fileID);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;解码内容已保存至：&#x27;</span>, decodedFilePath]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算错误位置</span></span><br><span class="line">original_bits = data_bits; <span class="comment">% 从原始数据转换而来</span></span><br><span class="line">decoded_bits = Decode;     <span class="comment">% 从decoded_str转换而来，确保长度一致</span></span><br><span class="line">errors_positions = [];     <span class="comment">% 初始化错误位置列表</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(original_bits)</span><br><span class="line">    <span class="keyword">if</span> original_bits(<span class="built_in">i</span>) ~= decoded_bits(<span class="built_in">i</span>)</span><br><span class="line">        errors_positions = [errors_positions, <span class="built_in">i</span>]; <span class="comment">% 记录错误位置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(errors_positions)</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span>, num2str(<span class="built_in">i</span>),<span class="string">&#x27;个错误位置 &#x27;</span>, <span class="string">&#x27;: &#x27;</span>, num2str(errors_positions(<span class="built_in">i</span>))]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 平均误比特率和误组率</span></span><br><span class="line">total_errors = <span class="built_in">length</span>(errors_positions);</span><br><span class="line">total_bits = <span class="built_in">length</span>(original_bits);</span><br><span class="line">average_bit_error_rate = total_errors / total_bits;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;平均误比特率: &#x27;</span>, num2str(average_bit_error_rate)]);</span><br><span class="line">block_error_rate = <span class="number">1</span> - (<span class="number">1</span> - average_bit_error_rate)^n;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;误组率: &#x27;</span>, num2str(block_error_rate)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成矩阵和校验矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[G, H]</span> = <span class="title">hamming_code_matrices</span><span class="params">(n, k)</span></span></span><br><span class="line">    [H, G, ~, ~] = hammgen(n-k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[encoded_stream, encode_str]</span> = <span class="title">HammingEncoding</span><span class="params">(data_bits, n, k)</span></span></span><br><span class="line">    <span class="comment">% 获取生成矩阵</span></span><br><span class="line">    [G, ~] = hamming_code_matrices(n, k);</span><br><span class="line">    <span class="comment">% disp(G);</span></span><br><span class="line">    <span class="comment">% 初始化编码结果的存储</span></span><br><span class="line">    encoded_stream = [];</span><br><span class="line">    <span class="comment">% 处理整个比特流</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data_bits) &gt;= k</span><br><span class="line">        <span class="comment">% 对当前k位数据进行编码</span></span><br><span class="line">        group = data_bits(<span class="number">1</span>:k);</span><br><span class="line">        <span class="comment">% 对当前组进行编码</span></span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>); </span><br><span class="line">        <span class="comment">% 累积编码结果</span></span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group]; </span><br><span class="line">        <span class="comment">% 移动到下一个k位数据</span></span><br><span class="line">        data_bits = data_bits(k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 处理剩余不足k位的数据（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(data_bits)</span><br><span class="line">        <span class="comment">% 补齐到k位</span></span><br><span class="line">        data_bits(<span class="keyword">end</span>+<span class="number">1</span>:k) = <span class="built_in">zeros</span>(<span class="number">1</span>, k - <span class="built_in">length</span>(data_bits));</span><br><span class="line">        group = data_bits;</span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>);</span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group];</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 显示最终编码后的比特流</span></span><br><span class="line">    encode_str = num2str(encoded_stream);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 解码（有纠错）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[decoded_data, decoded_str]</span> = <span class="title">HammingDecoding</span><span class="params">(encoded_stream, n, k)</span>    </span></span><br><span class="line">    [~, H] = hamming_code_matrices(n, k);     </span><br><span class="line">    decoded_data = [];    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(encoded_stream)&gt;=n</span><br><span class="line">        encoded_group = encoded_stream(<span class="number">1</span>:n);        </span><br><span class="line">        encoded_stream = encoded_stream(n+<span class="number">1</span>:<span class="keyword">end</span>);        </span><br><span class="line">        syndrome = <span class="built_in">mod</span>(encoded_group * H&#x27;, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">disp</span>(syndrome);</span><br><span class="line">        mat1 = <span class="built_in">eye</span>(n);</span><br><span class="line">        errvec = mat1*H&#x27;;</span><br><span class="line">        <span class="comment">% 如果syndrome非零，则存在错误</span></span><br><span class="line">        <span class="keyword">if</span> any(syndrome)            </span><br><span class="line">            <span class="keyword">for</span> index=<span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span>(syndrome==errvec(index,:))</span><br><span class="line">                    encoded_group = <span class="built_in">mod</span>(encoded_group+mat1(index,:),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>             </span><br><span class="line">        decoded_group = encoded_group(n-k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">        <span class="comment">% 累积解码数据，不忽略任何编码组</span></span><br><span class="line">        decoded_data = [decoded_data, decoded_group];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    decoded_data = [decoded_data, encoded_stream];</span><br><span class="line">    <span class="comment">%disp([&#x27;总纠错数：&#x27;,corrected_errors]);</span></span><br><span class="line">    <span class="comment">% 转换为字符串</span></span><br><span class="line">    decoded_str = num2str(decoded_data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 二进制对称信道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[transmittedStream]</span> = <span class="title">simulateBSC</span><span class="params">(encodedStream, ber)</span></span></span><br><span class="line">    <span class="comment">% 模拟二进制对称信道传输编码后的数据流</span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">%   encodedStream: 编码后的二进制数据流，1xN的二进制数组</span></span><br><span class="line">    <span class="comment">%   ber: 误码率，一个介于0和1之间的标量</span></span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">%   transmittedStream: 通过BSC传输后的数据流</span></span><br><span class="line">    <span class="comment">% 获取数据流的长度</span></span><br><span class="line">    streamLength = <span class="built_in">length</span>(encodedStream);</span><br><span class="line">    <span class="comment">% 生成随机错误分布，1表示发生错误，0表示无错误</span></span><br><span class="line">    errorVector = <span class="built_in">rand</span>(streamLength, <span class="number">1</span>) &lt; ber;</span><br><span class="line">    <span class="comment">% 应用错误到数据流</span></span><br><span class="line">    transmittedStream = encodedStream;</span><br><span class="line">    transmittedStream(errorVector == <span class="number">1</span>) = xor(encodedStream(errorVector == <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 返回经过错误注入的传输数据流</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

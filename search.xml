<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信息论与编码课程实验</title>
      <link href="/post/1/"/>
      <url>/post/1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&#x27;data.txt&#x27;</span>;</span><br><span class="line">[symbols, probabilities, selfinformation] = ProbabilityCalculation(file_path);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;信源符号：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(symbols);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;信源符号概率：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(probabilities);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;自信息量：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(selfinformation);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[symbols, probabilities, selfinformation]</span> = <span class="title">ProbabilityCalculation</span><span class="params">(filename)</span></span></span><br><span class="line">    <span class="comment">% 读取文件</span></span><br><span class="line">    fileID = fopen(filename, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    content = fscanf(fileID, <span class="string">&#x27;%c&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="comment">% 统计各个符号的出现次数</span></span><br><span class="line">    uniqueSymbols = unique(content);</span><br><span class="line">    symbolCounts = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(uniqueSymbols));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(uniqueSymbols)</span><br><span class="line">        symbolCounts(<span class="built_in">i</span>) = sum(content == uniqueSymbols(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 计算符号出现的概率</span></span><br><span class="line">    totalSymbols = sum(symbolCounts);</span><br><span class="line">    probabilities = symbolCounts / totalSymbols;</span><br><span class="line">    <span class="comment">% 计算自信息量</span></span><br><span class="line">    selfinformation = -<span class="built_in">log2</span>(probabilities);</span><br><span class="line">    <span class="comment">% 按照概率降序排列符号和概率</span></span><br><span class="line">    [sortedProbabilities, indices] = <span class="built_in">sort</span>(probabilities, <span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line">    symbols = uniqueSymbols(indices);</span><br><span class="line">    probabilities = sortedProbabilities;</span><br><span class="line">    <span class="comment">% 返回排序后的符号和对应的概率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[CODE, L_ave, yita, H] = HuffmanEncoding(probabilities);</span><br><span class="line"><span class="comment">% 展示输出码字、平均码长和编码效率</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;对应概率:&#x27;</span>,num2str(probabilities)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;对应码字:&#x27;</span>,CODE]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;平均码长:&#x27;</span>,num2str(L_ave)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;信源熵:&#x27;</span>,num2str(H)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;编码效率:&#x27;</span>,num2str(yita)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用新增函数进行编码并保存</span></span><br><span class="line">file_path = <span class="string">&#x27;data.txt&#x27;</span>;</span><br><span class="line">encodedFilePath = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line">decodedFilePath = <span class="string">&#x27;decoded_data.txt&#x27;</span>;</span><br><span class="line">EncodeAndSave(file_path, symbols, CODE, encodedFilePath);</span><br><span class="line">HuffmanDecoding(encodedFilePath, symbols, CODE, file_path, decodedFilePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Huffman码本对文件内容进行编码并保存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EncodeAndSave</span><span class="params">(file_path, symbols, CODE, encodedFilePath)</span></span></span><br><span class="line">    <span class="comment">% 读取原始文件内容</span></span><br><span class="line">    fileID = fopen(file_path, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    originalContent = fscanf(fileID, <span class="string">&#x27;%c&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="comment">% 初始化编码后的内容字符串</span></span><br><span class="line">    encodedContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">% 遍历原始内容的每个字符</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(originalContent)</span><br><span class="line">        <span class="comment">% 查找当前字符在symbols中的位置</span></span><br><span class="line">        symbolIndex = strfind(symbols, originalContent(<span class="built_in">i</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 如果找到，则根据索引从CODE中获取编码并添加到结果字符串</span></span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isempty</span>(symbolIndex)</span><br><span class="line">            encodedContent = strcat(encodedContent, CODE&#123;symbolIndex&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error([<span class="string">&#x27;未在符号集中找到字符：&#x27;</span>, originalContent(<span class="built_in">i</span>)]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 保存编码结果到新文件</span></span><br><span class="line">    fileID = fopen(encodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, encodedContent);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;编码内容已保存至：&#x27;</span>, encodedFilePath]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[CODE, L_ave, yita, H]</span> = <span class="title">HuffmanEncoding</span><span class="params">(probabilities)</span></span></span><br><span class="line">    p = probabilities;</span><br><span class="line">    N = <span class="built_in">length</span>(p);</span><br><span class="line">    <span class="comment">% 将概率排序并获得单步码字排序</span></span><br><span class="line">    code = strings(N<span class="number">-1</span>,N);   <span class="comment">% 初始化单步过程的码字</span></span><br><span class="line">    reflect = <span class="built_in">zeros</span>(N<span class="number">-1</span>,N);  <span class="comment">% 初始化位置对应向量</span></span><br><span class="line">    p_SD = p;                <span class="comment">% p_SD为每次得到的概率排序数组</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N<span class="number">-1</span>              <span class="comment">% i表示排序后第几个符号</span></span><br><span class="line">        M = <span class="built_in">length</span>(p_SD);</span><br><span class="line">        [p_SD,reflect(<span class="built_in">i</span>,<span class="number">1</span>:M)] = <span class="built_in">sort</span>(p_SD,<span class="string">&#x27;descend&#x27;</span>);<span class="comment">% 将概率从大到小进行排序</span></span><br><span class="line">        code(<span class="built_in">i</span>,M) = <span class="string">&#x27;1&#x27;</span>;                             <span class="comment">% 概率最小的是1</span></span><br><span class="line">        code(<span class="built_in">i</span>,M<span class="number">-1</span>) = <span class="string">&#x27;0&#x27;</span>;                           <span class="comment">% 概率第二小的暂且定义为0</span></span><br><span class="line">        p_SD(M<span class="number">-1</span>) = p_SD(M<span class="number">-1</span>) + p_SD(M);             <span class="comment">% 将最后两个概率相加</span></span><br><span class="line">        p_SD(M) = [];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 根据位置对应向量和单步过程的码字计算对应码字</span></span><br><span class="line">    CODE = strings(<span class="number">1</span>,N); <span class="comment">% 初始化对应码字</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        column = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">for</span> m = <span class="number">1</span>:N<span class="number">-1</span></span><br><span class="line">            [~, column] = <span class="built_in">find</span>(reflect(m,:) == column);</span><br><span class="line">            CODE(<span class="number">1</span>,<span class="built_in">i</span>) = strcat(CODE(<span class="number">1</span>,<span class="built_in">i</span>),code(m,column));</span><br><span class="line">            <span class="comment">% 将最小的两个概率映射成一个</span></span><br><span class="line">            <span class="keyword">if</span> column == N+<span class="number">1</span>-m</span><br><span class="line">                column = column<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    CODE = reverse(CODE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算平均码长</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">        L(<span class="built_in">i</span>) = <span class="built_in">size</span>(char(CODE(<span class="number">1</span>,<span class="built_in">i</span>)),<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    L_ave = sum(L.*p);</span><br><span class="line">    H = sum(-p.*<span class="built_in">log2</span>(p));</span><br><span class="line">    yita = H/L_ave; <span class="comment">% 计算编码效率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HuffmanDecoding</span><span class="params">(encodedFilePath, symbols, CODE, originalFilePath, decodedFilePath)</span></span></span><br><span class="line">    <span class="comment">% 读取编码后的文件内容</span></span><br><span class="line">    fileID = fopen(encodedFilePath, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    encodedContent = fscanf(fileID, <span class="string">&#x27;%s&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 构建逆码本</span></span><br><span class="line">    inv_CODE = cell(<span class="built_in">size</span>(CODE));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(CODE)</span><br><span class="line">        inv_CODE&#123;strcmp(CODE, CODE&#123;<span class="built_in">i</span>&#125;)&#125; = symbols(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 解码过程</span></span><br><span class="line">    decodedContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    currentCode = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(encodedContent)</span><br><span class="line">        currentCode = [currentCode, encodedContent(<span class="built_in">i</span>)];</span><br><span class="line">        foundSymbol = <span class="built_in">false</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">numel</span>(CODE)</span><br><span class="line">            <span class="keyword">if</span> strcmp(currentCode, CODE&#123;<span class="built_in">j</span>&#125;)</span><br><span class="line">                decodedContent = strcat(decodedContent, inv_CODE&#123;<span class="built_in">j</span>&#125;);</span><br><span class="line">                currentCode = <span class="string">&#x27;&#x27;</span>; <span class="comment">% 重置当前码，开始下一个码的匹配</span></span><br><span class="line">                foundSymbol = <span class="built_in">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 保存解码结果到新文件</span></span><br><span class="line">    fileID = fopen(decodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, decodedContent);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;解码内容已保存至：&#x27;</span>, decodedFilePath]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 与原始文件进行对比，计算误码率</span></span><br><span class="line">    originalFileContent = fileread(originalFilePath);</span><br><span class="line">    errors = sum(strcmp(decodedContent, originalFileContent) == <span class="number">0</span>);</span><br><span class="line">    totalChars = <span class="built_in">numel</span>(decodedContent);</span><br><span class="line">    errorRate = errors / totalChars;</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;误码率:&#x27;</span>, num2str(errorRate)]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置参数</span></span><br><span class="line">n = <span class="number">7</span>;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">file_path = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取文件内容</span></span><br><span class="line">fid = fopen(file_path, <span class="string">&#x27;rt&#x27;</span>); <span class="comment">% &#x27;rt&#x27; 表示读取文本文件</span></span><br><span class="line">dataStr = fscanf(fid, <span class="string">&#x27;%c&#x27;</span>); <span class="comment">% 读取全部字符</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% 初始化二进制向量</span></span><br><span class="line">data_bits = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(dataStr));</span><br><span class="line"><span class="comment">% 遍历字符串，转换字符到比特</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(dataStr)</span><br><span class="line">    <span class="keyword">if</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;1&#x27;</span> <span class="comment">% 字符&#x27;1&#x27;转换为二进制1</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elseif</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;0&#x27;</span> <span class="comment">% 字符&#x27;0&#x27;转换为二进制0</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码解码</span></span><br><span class="line">[Encode0, Encode_str] = HammingEncoding(data_bits, n, k);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设定错误转移概率的变量范围</span></span><br><span class="line">berRange = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.1</span>; <span class="comment">% 误码率从0到10%，以0.5%为步长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化曲线数据</span></span><br><span class="line">avgBitErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(berRange));</span><br><span class="line">blockErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(berRange));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 遍历每个误码率</span></span><br><span class="line"><span class="keyword">for</span> w = <span class="number">1</span>:<span class="built_in">length</span>(berRange)</span><br><span class="line">    ber = berRange(w);</span><br><span class="line">    [Encode] = simulateBSC(Encode0, ber);</span><br><span class="line">    [Decode, Decode_str] = HammingDecoding(Encode, n, k);    </span><br><span class="line">    <span class="comment">% 计算错误位置</span></span><br><span class="line">    original_bits = data_bits; <span class="comment">% 从原始数据转换而来</span></span><br><span class="line">    decoded_bits = Decode;     <span class="comment">% 从decoded_str转换而来，确保长度一致</span></span><br><span class="line">    errors_positions = [];     <span class="comment">% 初始化错误位置列表</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(original_bits)</span><br><span class="line">        <span class="keyword">if</span> original_bits(<span class="built_in">i</span>) ~= decoded_bits(<span class="built_in">i</span>)</span><br><span class="line">            errors_positions = [errors_positions, <span class="built_in">i</span>]; <span class="comment">% 记录错误位置</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    total_errors = <span class="built_in">length</span>(errors_positions);</span><br><span class="line">    total_bits = <span class="built_in">length</span>(original_bits);</span><br><span class="line">    <span class="comment">% 计算平均误比特率</span></span><br><span class="line">    average_bit_error_rate = total_errors / total_bits;</span><br><span class="line">    <span class="comment">% 计算平均误比特率</span></span><br><span class="line">    block_error_rate = <span class="number">1</span> - (<span class="number">1</span> - average_bit_error_rate)^n;</span><br><span class="line">          </span><br><span class="line">    <span class="comment">% 记录数据</span></span><br><span class="line">    avgBitErrorRate(w) = average_bit_error_rate;</span><br><span class="line">    blockErrorRate(w) = block_error_rate;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制曲线图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制曲线图</span></span><br><span class="line"><span class="built_in">plot</span>(berRange, avgBitErrorRate, <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;Marker&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">% plot(berRange, blockErrorRate, &#x27;b-&#x27;, &#x27;LineWidth&#x27;, 2, &#x27;Marker&#x27;, &#x27;.&#x27;, &#x27;MarkerSize&#x27;, 6);</span></span><br><span class="line"><span class="comment">% 添加标题和轴标签</span></span><br><span class="line">title(<span class="string">&#x27;平均误比特率与二进制对称信道错误转移概率的关系&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;二进制对称信道错误转移概率 (BER)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;平均误比特率&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置坐标轴范围和精度</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">0.1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 可以选择设置网格线</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成矩阵和校验矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[G, H]</span> = <span class="title">hamming_code_matrices</span><span class="params">(n, k)</span></span></span><br><span class="line">    [H, G, ~, ~] = hammgen(n-k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[encoded_stream, encode_str]</span> = <span class="title">HammingEncoding</span><span class="params">(data_bits, n, k)</span></span></span><br><span class="line">    <span class="comment">% 获取生成矩阵</span></span><br><span class="line">    [G, ~] = hamming_code_matrices(n, k);</span><br><span class="line">    <span class="comment">% disp(G);</span></span><br><span class="line">    <span class="comment">% 初始化编码结果的存储</span></span><br><span class="line">    encoded_stream = [];</span><br><span class="line">    <span class="comment">% 处理整个比特流</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data_bits) &gt;= k</span><br><span class="line">        <span class="comment">% 对当前k位数据进行编码</span></span><br><span class="line">        group = data_bits(<span class="number">1</span>:k);</span><br><span class="line">        <span class="comment">% 对当前组进行编码</span></span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>); </span><br><span class="line">        <span class="comment">% 累积编码结果</span></span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group]; </span><br><span class="line">        <span class="comment">% 移动到下一个k位数据</span></span><br><span class="line">        data_bits = data_bits(k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 处理剩余不足k位的数据（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(data_bits)</span><br><span class="line">        <span class="comment">% 补齐到k位</span></span><br><span class="line">        data_bits(<span class="keyword">end</span>+<span class="number">1</span>:k) = <span class="built_in">zeros</span>(<span class="number">1</span>, k - <span class="built_in">length</span>(data_bits));</span><br><span class="line">        group = data_bits;</span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>);</span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group];</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 显示最终编码后的比特流</span></span><br><span class="line">    encode_str = num2str(encoded_stream);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 解码（有纠错）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[decoded_data, decoded_str]</span> = <span class="title">HammingDecoding</span><span class="params">(encoded_stream, n, k)</span>    </span></span><br><span class="line">    [~, H] = hamming_code_matrices(n, k);     </span><br><span class="line">    decoded_data = [];    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(encoded_stream)&gt;=n</span><br><span class="line">        encoded_group = encoded_stream(<span class="number">1</span>:n);        </span><br><span class="line">        encoded_stream = encoded_stream(n+<span class="number">1</span>:<span class="keyword">end</span>);        </span><br><span class="line">        syndrome = <span class="built_in">mod</span>(encoded_group * H&#x27;, <span class="number">2</span>);</span><br><span class="line">        mat1 = <span class="built_in">eye</span>(n);</span><br><span class="line">        errvec = mat1*H&#x27;;</span><br><span class="line">        <span class="comment">% 如果syndrome非零，则存在错误</span></span><br><span class="line">        <span class="keyword">if</span> any(syndrome)            </span><br><span class="line">            <span class="keyword">for</span> index=<span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span>(syndrome==errvec(index,:))</span><br><span class="line">                    encoded_group = <span class="built_in">mod</span>(encoded_group+mat1(index,:),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>             </span><br><span class="line">        decoded_group = encoded_group(n-k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">        <span class="comment">% 累积解码数据，不忽略任何编码组</span></span><br><span class="line">        decoded_data = [decoded_data, decoded_group];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    decoded_data = [decoded_data, encoded_stream];</span><br><span class="line">    <span class="comment">%disp([&#x27;总纠错数：&#x27;,corrected_errors]);</span></span><br><span class="line">    <span class="comment">% 转换为字符串</span></span><br><span class="line">    decoded_str = num2str(decoded_data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 二进制对称信道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[transmittedStream]</span> = <span class="title">simulateBSC</span><span class="params">(encodedStream, ber)</span></span></span><br><span class="line">    <span class="comment">% 模拟二进制对称信道传输编码后的数据流</span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">%   encodedStream: 编码后的二进制数据流，1xN的二进制数组</span></span><br><span class="line">    <span class="comment">%   ber: 误码率，一个介于0和1之间的标量</span></span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">%   transmittedStream: 通过BSC传输后的数据流</span></span><br><span class="line">    <span class="comment">% 获取数据流的长度</span></span><br><span class="line">    streamLength = <span class="built_in">length</span>(encodedStream);</span><br><span class="line">    <span class="comment">% 生成随机错误分布，1表示发生错误，0表示无错误</span></span><br><span class="line">    errorVector = <span class="built_in">rand</span>(streamLength, <span class="number">1</span>) &lt; ber;</span><br><span class="line">    <span class="comment">% 应用错误到数据流</span></span><br><span class="line">    transmittedStream = encodedStream;</span><br><span class="line">    transmittedStream(errorVector == <span class="number">1</span>) = xor(encodedStream(errorVector == <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 返回经过错误注入的传输数据流</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置参数</span></span><br><span class="line">n = <span class="number">7</span>;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">file_path = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取文件内容</span></span><br><span class="line">fid = fopen(file_path, <span class="string">&#x27;rt&#x27;</span>); <span class="comment">% &#x27;rt&#x27; 表示读取文本文件</span></span><br><span class="line">dataStr = fscanf(fid, <span class="string">&#x27;%c&#x27;</span>);  <span class="comment">% 读取全部字符</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% 初始化二进制向量</span></span><br><span class="line">data_bits = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(dataStr));</span><br><span class="line"><span class="comment">% 遍历字符串，转换字符到比特</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(dataStr)</span><br><span class="line">    <span class="keyword">if</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;1&#x27;</span> <span class="comment">% 字符&#x27;1&#x27;转换为二进制1</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elseif</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;0&#x27;</span> <span class="comment">% 字符&#x27;0&#x27;转换为二进制0</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码解码</span></span><br><span class="line">[Encode, Encode_str] = HammingEncoding(data_bits, n, k);</span><br><span class="line">ber = <span class="number">0.001</span>; <span class="comment">% 设定误码率为0.1%</span></span><br><span class="line">[G, H] = hamming_code_matrices(n, k);</span><br><span class="line">[Encode] = simulateBSC(Encode, ber);</span><br><span class="line">[Decode, Decode_str] = HammingDecoding(Encode, n, k);</span><br><span class="line">decodedFilePath = <span class="string">&#x27;decoded.txt&#x27;</span>;</span><br><span class="line">fileID = fopen(decodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, Decode_str);</span><br><span class="line">fclose(fileID);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;解码内容已保存至：&#x27;</span>, decodedFilePath]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算错误位置</span></span><br><span class="line">original_bits = data_bits; <span class="comment">% 从原始数据转换而来</span></span><br><span class="line">decoded_bits = Decode;     <span class="comment">% 从decoded_str转换而来，确保长度一致</span></span><br><span class="line">errors_positions = [];     <span class="comment">% 初始化错误位置列表</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(original_bits)</span><br><span class="line">    <span class="keyword">if</span> original_bits(<span class="built_in">i</span>) ~= decoded_bits(<span class="built_in">i</span>)</span><br><span class="line">        errors_positions = [errors_positions, <span class="built_in">i</span>]; <span class="comment">% 记录错误位置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(errors_positions)</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span>, num2str(<span class="built_in">i</span>),<span class="string">&#x27;个错误位置 &#x27;</span>, <span class="string">&#x27;: &#x27;</span>, num2str(errors_positions(<span class="built_in">i</span>))]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 平均误比特率和误组率</span></span><br><span class="line">total_errors = <span class="built_in">length</span>(errors_positions);</span><br><span class="line">total_bits = <span class="built_in">length</span>(original_bits);</span><br><span class="line">average_bit_error_rate = total_errors / total_bits;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;平均误比特率: &#x27;</span>, num2str(average_bit_error_rate)]);</span><br><span class="line">block_error_rate = <span class="number">1</span> - (<span class="number">1</span> - average_bit_error_rate)^n;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;误组率: &#x27;</span>, num2str(block_error_rate)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成矩阵和校验矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[G, H]</span> = <span class="title">hamming_code_matrices</span><span class="params">(n, k)</span></span></span><br><span class="line">    [H, G, ~, ~] = hammgen(n-k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[encoded_stream, encode_str]</span> = <span class="title">HammingEncoding</span><span class="params">(data_bits, n, k)</span></span></span><br><span class="line">    <span class="comment">% 获取生成矩阵</span></span><br><span class="line">    [G, ~] = hamming_code_matrices(n, k);</span><br><span class="line">    <span class="comment">% disp(G);</span></span><br><span class="line">    <span class="comment">% 初始化编码结果的存储</span></span><br><span class="line">    encoded_stream = [];</span><br><span class="line">    <span class="comment">% 处理整个比特流</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data_bits) &gt;= k</span><br><span class="line">        <span class="comment">% 对当前k位数据进行编码</span></span><br><span class="line">        group = data_bits(<span class="number">1</span>:k);</span><br><span class="line">        <span class="comment">% 对当前组进行编码</span></span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>); </span><br><span class="line">        <span class="comment">% 累积编码结果</span></span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group]; </span><br><span class="line">        <span class="comment">% 移动到下一个k位数据</span></span><br><span class="line">        data_bits = data_bits(k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 处理剩余不足k位的数据（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(data_bits)</span><br><span class="line">        <span class="comment">% 补齐到k位</span></span><br><span class="line">        data_bits(<span class="keyword">end</span>+<span class="number">1</span>:k) = <span class="built_in">zeros</span>(<span class="number">1</span>, k - <span class="built_in">length</span>(data_bits));</span><br><span class="line">        group = data_bits;</span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>);</span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group];</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 显示最终编码后的比特流</span></span><br><span class="line">    encode_str = num2str(encoded_stream);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 解码（有纠错）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[decoded_data, decoded_str]</span> = <span class="title">HammingDecoding</span><span class="params">(encoded_stream, n, k)</span>    </span></span><br><span class="line">    [~, H] = hamming_code_matrices(n, k);     </span><br><span class="line">    decoded_data = [];    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(encoded_stream)&gt;=n</span><br><span class="line">        encoded_group = encoded_stream(<span class="number">1</span>:n);        </span><br><span class="line">        encoded_stream = encoded_stream(n+<span class="number">1</span>:<span class="keyword">end</span>);        </span><br><span class="line">        syndrome = <span class="built_in">mod</span>(encoded_group * H&#x27;, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">disp</span>(syndrome);</span><br><span class="line">        mat1 = <span class="built_in">eye</span>(n);</span><br><span class="line">        errvec = mat1*H&#x27;;</span><br><span class="line">        <span class="comment">% 如果syndrome非零，则存在错误</span></span><br><span class="line">        <span class="keyword">if</span> any(syndrome)            </span><br><span class="line">            <span class="keyword">for</span> index=<span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span>(syndrome==errvec(index,:))</span><br><span class="line">                    encoded_group = <span class="built_in">mod</span>(encoded_group+mat1(index,:),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>             </span><br><span class="line">        decoded_group = encoded_group(n-k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">        <span class="comment">% 累积解码数据，不忽略任何编码组</span></span><br><span class="line">        decoded_data = [decoded_data, decoded_group];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    decoded_data = [decoded_data, encoded_stream];</span><br><span class="line">    <span class="comment">%disp([&#x27;总纠错数：&#x27;,corrected_errors]);</span></span><br><span class="line">    <span class="comment">% 转换为字符串</span></span><br><span class="line">    decoded_str = num2str(decoded_data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 二进制对称信道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[transmittedStream]</span> = <span class="title">simulateBSC</span><span class="params">(encodedStream, ber)</span></span></span><br><span class="line">    <span class="comment">% 模拟二进制对称信道传输编码后的数据流</span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">%   encodedStream: 编码后的二进制数据流，1xN的二进制数组</span></span><br><span class="line">    <span class="comment">%   ber: 误码率，一个介于0和1之间的标量</span></span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">%   transmittedStream: 通过BSC传输后的数据流</span></span><br><span class="line">    <span class="comment">% 获取数据流的长度</span></span><br><span class="line">    streamLength = <span class="built_in">length</span>(encodedStream);</span><br><span class="line">    <span class="comment">% 生成随机错误分布，1表示发生错误，0表示无错误</span></span><br><span class="line">    errorVector = <span class="built_in">rand</span>(streamLength, <span class="number">1</span>) &lt; ber;</span><br><span class="line">    <span class="comment">% 应用错误到数据流</span></span><br><span class="line">    transmittedStream = encodedStream;</span><br><span class="line">    transmittedStream(errorVector == <span class="number">1</span>) = xor(encodedStream(errorVector == <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 返回经过错误注入的传输数据流</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SCTF 2024 Crypto WriteUp</title>
      <link href="/post/30110/"/>
      <url>/post/30110/</url>
      
        <content type="html"><![CDATA[<h2 id="sctf-2024-crypto-writeup">SCTF 2024 Crypto WriteUp</h2><p>这次题目质量都可以，每一个题都能学到新东西。</p><p>Reference: <a href="https://blog.wm-team.cn/index.php/archives/82/">SCTF 2024 By W&amp;M - W&amp;M Team (wm-team.cn)</a></p><h3 id="1-signin">1. Signin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RSA</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nbits</span>):</span><br><span class="line">        self.nbits = nbits</span><br><span class="line">        self.p, self.q = self.getPrimes()</span><br><span class="line">        self.n = self.p*self.q</span><br><span class="line">        self.Gift = self.Gift()</span><br><span class="line">        self.priv, self.pub = self.keyGen()</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPrimes</span>(<span class="params">self</span>):</span><br><span class="line">        nbits = self.nbits</span><br><span class="line">        p = random_prime(<span class="number">2</span>^(nbits-<span class="number">1</span>),lbound=<span class="number">2</span>^(nbits-<span class="number">2</span>))</span><br><span class="line">        q = random_prime(<span class="number">2</span>^(nbits-<span class="number">1</span>),lbound=<span class="number">2</span>^(nbits-<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">while</span> p == q:</span><br><span class="line">            q = random_prime(<span class="number">2</span>^(nbits-<span class="number">1</span>),lbound=<span class="number">2</span>^(nbits-<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> p,q</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Gift</span>(<span class="params">self</span>):</span><br><span class="line">        p,q = self.p, self.q</span><br><span class="line">        <span class="keyword">return</span> (p^<span class="number">2</span> + p + <span class="number">1</span>)*(q^<span class="number">2</span> + q + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keyGen</span>(<span class="params">self</span>):</span><br><span class="line">        nbits = self.nbits</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            d = randint(<span class="number">2</span>^(nbits//<span class="number">4</span>),<span class="number">2</span>^(nbits//<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> gcd(d,self.Gift) != <span class="number">1</span>:</span><br><span class="line">                d = randint(<span class="number">2</span>^(nbits//<span class="number">4</span>),<span class="number">2</span>^(nbits//<span class="number">2</span>))</span><br><span class="line">            e = <span class="built_in">pow</span>(d,-<span class="number">1</span>,self.phi)</span><br><span class="line">            <span class="keyword">return</span> (self.p,self.q,self.n,e,d),(self.n,e)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">RRR = RSA(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">bp = long_to_bytes(<span class="built_in">int</span>(RRR.p))</span><br><span class="line">FLAG = <span class="string">&#x27;SCTF&#123;&#x27;</span>+md5(bp).hexdigest()+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;N = <span class="subst">&#123;RRR.n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = <span class="subst">&#123;RRR.pub[<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">N = 32261421478213846055712670966502489204755328170115455046538351164751104619671102517649635534043658087736634695616391757439732095084483689790126957681118278054587893972547230081514687941476504846573346232349396528794022902849402462140720882761797608629678538971832857107919821058604542569600500431547986211951</span></span><br><span class="line"><span class="string">e = 334450817132213889699916301332076676907807495738301743367532551341259554597455532787632746522806063413194057583998858669641413549469205803510032623432057274574904024415310727712701532706683404590321555542304471243731711502894688623443411522742837178384157350652336133957839779184278283984964616921311020965540513988059163842300284809747927188585982778365798558959611785248767075169464495691092816641600277394649073668575637386621433598176627864284154484501969887686377152288296838258930293614942020655916701799531971307171423974651394156780269830631029915305188230547099840604668445612429756706738202411074392821840</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始算了很久，发现题中的<code>e = pow(d,-1,self.phi)</code>中的<code>self.phi</code>并没有在<code>__init__(self, nbits)</code>中说明</p><p>结合题目提示：Oops! Ψ is not good for encrypt, but good for gift.</p><p>这个<code>self.phi = self.Gift</code>（实际上<code>gcd(d,self.Gift) != 1</code>也是提示这个）</p><p>然后就是推导</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>×</mo><mi>d</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mi>h</mi><mi>i</mi><mspace linebreak="newline"></mspace><mi>e</mi><mo>×</mo><mi>d</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>k</mi><mo>×</mo><mi>p</mi><mi>h</mi><mi>i</mi><mspace linebreak="newline"></mspace><mi>e</mi><mo>×</mo><mi>d</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>k</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>q</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>e</mi><mo>×</mo><mi>d</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>k</mi><mo>×</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mi>q</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>+</mo><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>p</mi><mo>+</mo><mi>q</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>l</mi><mi>e</mi><mi>t</mi><mtext>  </mtext><mi>s</mi><mo>=</mo><mi>p</mi><mo>+</mo><mi>q</mi><mspace linebreak="newline"></mspace><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mi>k</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi><mo>×</mo><mi>s</mi><mo>+</mo><msup><mi>s</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi><mo>+</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>e</mi></mrow><annotation encoding="application/x-tex">e \times d \equiv 1 \mod phi\\e \times d = 1 + k \times phi\\e \times d = 1 + k \times (p^2+p+1) \times (q^2+q+1)\\e \times d = 1+k\times((n^2)+n\times(p+q)+n+p^2+q^2+p+q+1)\\let\;s = p + q\\1+1+k\times(n^2+n\times s+s^2-n+s+1) = 0 \mod e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span></span></span></span></span></p><p>上面模方程中有两个未知量<code>k</code>和<code>s</code></p><p>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>×</mo><mi>d</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>k</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e \times d = 1 + k \times (p^2+p) \times (q^2+q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span> ，其中e.bit_length=4*nbits，nbits//4&lt;d.bit_length&lt;nbits//2，所以k.bit_length&lt;nbits//2，</p><p>用二元coppersmith解</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">d = f.degree()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(f, Polynomial):</span><br><span class="line">x, = polygens(f.base_ring(), f.variable_name(), <span class="number">1</span>)</span><br><span class="line">f = f(x)</span><br><span class="line"></span><br><span class="line">R = f.base_ring()</span><br><span class="line">N = R.cardinality()</span><br><span class="line"></span><br><span class="line">f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">base = N^(m-i) * f^i</span><br><span class="line"><span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">G.append(g)</span><br><span class="line"></span><br><span class="line">B, monomials = G.coefficient_matrix()</span><br><span class="line">monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line"><span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">B = B.change_ring(QQ)</span><br><span class="line"><span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">B.rescale_col(i, <span class="number">1</span>/factor)</span><br><span class="line"></span><br><span class="line">H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B*monomials):</span><br><span class="line">H.append(h)</span><br><span class="line">I = H.ideal()</span><br><span class="line"><span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">H.pop()</span><br><span class="line"><span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">roots = []</span><br><span class="line"><span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">roots.append(root)</span><br><span class="line"><span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">N = <span class="number">32261421478213846055712670966502489204755328170115455046538351164751104619671102517649635534043658087736634695616391757439732095084483689790126957681118278054587893972547230081514687941476504846573346232349396528794022902849402462140720882761797608629678538971832857107919821058604542569600500431547986211951</span></span><br><span class="line">e = <span class="number">334450817132213889699916301332076676907807495738301743367532551341259554597455532787632746522806063413194057583998858669641413549469205803510032623432057274574904024415310727712701532706683404590321555542304471243731711502894688623443411522742837178384157350652336133957839779184278283984964616921311020965540513988059163842300284809747927188585982778365798558959611785248767075169464495691092816641600277394649073668575637386621433598176627864284154484501969887686377152288296838258930293614942020655916701799531971307171423974651394156780269830631029915305188230547099840604668445612429756706738202411074392821840</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">32261421478213846055712670966502489204755328170115455046538351164751104619671102517649635534043658087736634695616391757439732095084483689790126957681118278054587893972547230081514687941476504846573346232349396528794022902849402462140720882761797608629678538971832857107919821058604542569600500431547986211951</span></span><br><span class="line">e = <span class="number">334450817132213889699916301332076676907807495738301743367532551341259554597455532787632746522806063413194057583998858669641413549469205803510032623432057274574904024415310727712701532706683404590321555542304471243731711502894688623443411522742837178384157350652336133957839779184278283984964616921311020965540513988059163842300284809747927188585982778365798558959611785248767075169464495691092816641600277394649073668575637386621433598176627864284154484501969887686377152288296838258930293614942020655916701799531971307171423974651394156780269830631029915305188230547099840604668445612429756706738202411074392821840</span></span><br><span class="line"></span><br><span class="line">R.&lt;s,k&gt; = PolynomialRing(Zmod(e))</span><br><span class="line">f = <span class="number">1</span>+k*(n^<span class="number">2</span>+n*s+s^<span class="number">2</span>-n+s+<span class="number">1</span>)</span><br><span class="line">bounds=(<span class="number">2</span>^<span class="number">513</span>,<span class="number">2</span>^<span class="number">256</span>)</span><br><span class="line"><span class="built_in">print</span>(small_roots(f , bounds , m=<span class="number">3</span> , d=<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(root)</span><br></pre></td></tr></table></figure><h3 id="2-不完全阻塞干扰">2. 不完全阻塞干扰</h3><p>一个intelligence.pkl文件，从文件中读取序列化的对象并还原为原来的Python对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件用于读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;intelligence.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 使用pickle.load()从文件中读取序列化的对象并还原为原来的Python对象</span></span><br><span class="line">    loaded_data = pickle.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印加载的数据</span></span><br><span class="line"><span class="built_in">print</span>(loaded_data)</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The ship crashed into the sun, causing a massive magnetic storm</span></span><br><span class="line"><span class="comment">#part of script</span></span><br><span class="line">msg = bytes_to_long(FLAG)</span><br><span class="line">n = p^<span class="number">5</span>*q^<span class="number">2</span></span><br><span class="line">phi = p^<span class="number">4</span>*(p-<span class="number">1</span>)*q*(q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = inverse(d,phi)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="comment"># c = 145554802564989933772666853449758467748433820771006616874558211691441588216921262672588167631397770260815821197485462873358280668164496459053150659240485200305314288108259163251006446515109018138298662011636423264380170119025895000021651886702521266669653335874489612060473962259596489445807308673497717101487224092493721535129391781431853820808463529747944795809850314965769365750993208968116864575686200409653590102945619744853690854644813177444995458528447525184291487005845375945194236352007426925987404637468097524735905540030962884807790630389799495153548300450435815577962308635103143187386444035094151992129110267595908492217520416633466787688326809639286703608138336958958449724993250735997663382433125872982238289419769011271925043792124263306262445811864346081207309546599603914842331643196984128658943528999381048833301951569809038023921101787071345517702911344900151843968213911899353962451480195808768038035044446206153179737023140055693141790385662942050774439391111437140968754546526191031278186881116757268998843581015398070043778631790328583529667194481319953424389090869226474999123124532354330671462280959215310810005231660418399403337476289138527331553267291013945347058144254374287422377547369897793812634181778309679601143245890494670013019155942690562552431527149178906855998534415120428884098317318129659099377634006938812654262148522236268027388683027513663867042278407716812565374141362015467076472409873946275500942547114202939578755575249750674734066843408758067001891408572444119999801055605577737379889503505649865554353749621313679734666376467890526136184241450593948838055612677564667946098308716892133196862716086041690426537245252116765796203427832657608512488619438752378624483485364908432609100523022628791451171084583484294929190998796485805496852608557456380717623462846198636093701726099310737244471075079541022111303662778829695340275795782631315412134758717966727565043332335558077486037869874106819581519353856396937832498623662166446395755447101393825864584024239951058366713573567250863658531585064635727070458886746791722270803893438211751165831616861912569513431821959562450032831904268205845224077709362068478</span></span><br></pre></td></tr></table></figure><p>另有一个损毁的私钥文件cert.pem</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIIFQKCA4AGfwqk6XSmOh/+jVwj5dPEMWU65BzHRvMF9iqfGT8iSGy37xsnVjSB</span><br><span class="line">j0bQdSpROeGZGCcfoNfSe8Zg0rckFNCOpSyIN/lJx7rswwKboxcn7zvxINmSbALX</span><br><span class="line">QS8YfpjcVt0HuYfSzBka1WFkoUTyiy9woV0QVYik8n+7KJH8UnvWiQpfeVtcSEdq</span><br><span class="line">a/nftnt+Hrx7Gwhs0otYxolVv99E7M4R/6zfZUVRsVm3gyBAzCjujr6kj4Zy1T49</span><br><span class="line">6I/Pu1+ydrUDiA3TTVmTM13fjMuWwbTXn1AtchBHZa2cKxhYoXrz1b5E+jy/S47r</span><br><span class="line">lCqjlCo4cdLGWscCiRI/wun5sly/y9eEEJYGD6UEw6B7WRSTxkyI0LtFKFqFtffV</span><br><span class="line">nbmPqgDCzT+7Y9pZkgXxyrDfUs97QxoO5KfjVpZUbOnQPvWV7O6S0hQskul9J0ST</span><br><span class="line">lwNFW0xw3sJ8Mh7GuDwCliLoOp4NVdCyWNldTmEpGGXdp23GGfzpV3mQQpxud+nU</span><br><span class="line">B4HjsvRJcBuD6LDGxm6zgPlkc+XUIu/uiysOiLcWsAp5ydUUyjrZ0t7lJmCf+VQX</span><br><span class="line">MqQZjRG52/uy5Vwk2A6lItB4bjNV8jYGpdOKct5O78i2v8SCJIooYstp2ODj0xZZ</span><br><span class="line">fanYCCi+hQVPrxX8NpyqyvuBXGlzwXGUBoPVahoZZ7Cbf/o/vlsuCGmXWdhNcWA/</span><br><span class="line">UWRHaWuycyKmnzn2yiU+ANyVVdX5cygHDEZ/NmPMSJqtEw8oxC81v4jFcZIKuSrL</span><br><span class="line">j3XQPjWnUQPFvZbwYclr0Cr24dGRsN0WS8chN3AD7b9dPvZaXpBGOFNWtSFiO+<span class="number">43</span></span><br><span class="line">8WSFCgp6+w7U5+i9mv4SmPfVMrya2UGBLTMq7OddHMyx/2n9QrMfJIrledng1qFL</span><br><span class="line">BUbnhLqUDjK9AcOV34/0WEBARitUefoHM21QPcMy5w/AbZRjKX/AQrYj1W+H76pS</span><br><span class="line">WptYDjFNkNEhGJPtQHomUI3qoKE8nujJArnhw6Av6aUUUsAu573MhcDv9jiR4kcD</span><br><span class="line">vSZdnJ2/RW4q+UCVOLzg/sx+urICZqqrBsdmw+ps2py5ul4dAkt9w9c+dvajMxl7</span><br><span class="line">rYfE+zTVZaABSqxygl5Brc/q2tyHrO9ArYS3xVaRq61WG+BVDqCpiEcMQnQyrLj+</span><br><span class="line">srnS0lmPsgibuRu9nLGZ6JLTYWTYvz7NVFdqlxNAR6EtqEIHSFu05QIDAQABAoID</span><br><span class="line">gAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoGBAIBj0KIYduXOHiEB</span><br><span class="line">wgAVUpBm7Zl2iC0QAqKe/g8v38wnQ/yaS1tlHMlxCGmeyi+x89kxdbrjQ+fJLkpB</span><br><span class="line">xy0F5XAZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAoGBAOTw/kn5rhSSwJegqYj6cYdmJf5PzgWw</span><br><span class="line">IE8f30PsZLTaxpnSjhZu/fx1YtGeWMNJPZEANlzyhAtGwPbujZZIBxcP8sE8TrgB</span><br><span class="line">LsqzeGKjkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAA</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件以损坏，无法用openssl读取，写代码将base64转为16进制hex</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cert.pem&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">key_64 = <span class="string">&#x27;&#x27;</span>.join(data.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">key_num = libnum.s2n(base64.b64decode(key_64))</span><br><span class="line">key_hex = <span class="built_in">hex</span>(key_num)[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(key_hex)</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">3082081502820380067f0aa4e974a63a1ffe8d5c23e5d3c431653ae41cc746f305f62a9f193f22486cb7ef1b275634818f46d0752a5139e19918271fa0d7d27bc660d2b72414d08ea52c8837f949c7baecc3029ba31727ef3bf120d9926c02d7412f187e98dc56dd07b987d2cc191ad56164a144f28b2f70a15d105588a4f27fbb2891fc527bd6890a5f795b5c48476a6bf9dfb67b7e1ebc7b1b086cd28b58c68955bfdf44ecce11ffacdf654551b159b7832040cc28ee8ebea48f8672d53e3de88fcfbb5fb276b503880dd34d5993335ddf8ccb96c1b4d79f502d72104765ad9c2b1858a17af3d5be44fa3cbf4b8eeb942aa3942a3871d2c65ac70289123fc2e9f9b25cbfcbd7841096060fa504c3a07b591493c64c88d0bb45285a85b5f7d59db98faa00c2cd3fbb63da599205f1cab0df52cf7b431a0ee4a7e35696546ce9d03ef595ecee92d2142c92e97d2744939703455b4c70dec27c321ec6b83c029622e83a9e0d55d0b258d95d4e61291865dda76dc619fce9577990429c6e77e9d40781e3b2f449701b83e8b0c6c66eb380f96473e5d422efee8b2b0e88b716b00a79c9d514ca3ad9d2dee526609ff9541732a4198d11b9dbfbb2e55c24d80ea522d0786e3355f23606a5d38a72de4eefc8b6bfc482248a2862cb69d8e0e3d316597da9d80828be85054faf15fc369caacafb815c6973c171940683d56a1a1967b09b7ffa3fbe5b2e08699759d84d71603f516447696bb27322a69f39f6ca253e00dc9555d5f97328070c467f3663cc489aad130f28c42f35bf88c571920ab92acb8f75d03e35a75103c5bd96f061c96bd02af6e1d191b0dd164bc721377003edbf5d3ef65a5e9046385356b521623bee37f164850a0a7afb0ed4e7e8bd9afe1298f7d532bc9ad941812d332aece75d1cccb1ff69fd42b31f248ae579d9e0d6a14b0546e784ba940e32bd01c395df8ff4584040462b5479fa07336d503dc332e70fc06d9463297fc042b623d56f87efaa525a9b580e314d90d1211893ed407a26508deaa0a13c9ee8c902b9e1c3a02fe9a51452c02ee7bdcc85c0eff63891e24703bd265d9c9dbf456e2af9409538bce0fecc7ebab20266aaab06c766c3ea6cda9cb9ba5e1d024b7dc3d73e76f6a333197bad87c4fb34d565a0014aac72825e41adcfeadadc87acef40ad84b7c55691abad561be0550ea0a988470c427432acb8feb2b9d2d2598fb2089bb91bbd9cb199e892d36164d8bf3ecd54576a97134047a12da84207485bb4e50203010001028203800400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000028181008063d0a21876e5ce1e2101c20015529066ed9976882d1002a29efe0f2fdfcc2743fc9a4b5b651cc97108699eca2fb1f3d93175bae343e7c92e4a41c72d05e5701940000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002818100e4f0fe49f9ae1492c097a0a988fa71876625fe4fce05b0204f1fdf43ec64b4dac699d28e166efdfc7562d19e58c3493d9100365cf2840b46c0f6ee8d964807170ff2c13c4eb8012ecab37862a3900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>找资料学习了一下RSA私钥文件格式</p><ul><li><a href="https://lazzzaro.github.io/2020/05/06/crypto-RSA/#RSA%E7%A7%81%E9%92%A5">RSA | Lazzaro (lazzzaro.github.io)</a></li><li><a href="https://www.cnblogs.com/jukan/p/5527922.html">OPENSSL中RSA私钥文件（PEM格式）解析【一】 - mydddfly - 博客园 (cnblogs.com)</a></li></ul><p>私钥中各参数顺序<code>n,e,d,p,q,dp,dq,iq</code>，后面几个参数非必须写入私钥中</p><p>私钥文件首先是标签头<code>30820815</code>，其中<code>82</code>表示后面的两个字节<code>0815</code>为文件长度（这里注意是字节长度，换算成bit位要再×8），即私钥长<code>0x0815bytes</code></p><p>后面<code>02820380</code>中<code>02</code>是分隔符，<code>82</code>表示后面两个字节<code>0380</code>为参数<code>n</code>的长度，即<code>n.length=0x0380bytes</code>，得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0x067f0aa4e974a63a1ffe8d5c23e5d3c431653ae41cc746f305f62a9f193f22486cb7ef1b275634818f46d0752a5139e19918271fa0d7d27bc660d2b72414d08ea52c8837f949c7baecc3029ba31727ef3bf120d9926c02d7412f187e98dc56dd07b987d2cc191ad56164a144f28b2f70a15d105588a4f27fbb2891fc527bd6890a5f795b5c48476a6bf9dfb67b7e1ebc7b1b086cd28b58c68955bfdf44ecce11ffacdf654551b159b7832040cc28ee8ebea48f8672d53e3de88fcfbb5fb276b503880dd34d5993335ddf8ccb96c1b4d79f502d72104765ad9c2b1858a17af3d5be44fa3cbf4b8eeb942aa3942a3871d2c65ac70289123fc2e9f9b25cbfcbd7841096060fa504c3a07b591493c64c88d0bb45285a85b5f7d59db98faa00c2cd3fbb63da599205f1cab0df52cf7b431a0ee4a7e35696546ce9d03ef595ecee92d2142c92e97d2744939703455b4c70dec27c321ec6b83c029622e83a9e0d55d0b258d95d4e61291865dda76dc619fce9577990429c6e77e9d40781e3b2f449701b83e8b0c6c66eb380f96473e5d422efee8b2b0e88b716b00a79c9d514ca3ad9d2dee526609ff9541732a4198d11b9dbfbb2e55c24d80ea522d0786e3355f23606a5d38a72de4eefc8b6bfc482248a2862cb69d8e0e3d316597da9d80828be85054faf15fc369caacafb815c6973c171940683d56a1a1967b09b7ffa3fbe5b2e08699759d84d71603f516447696bb27322a69f39f6ca253e00dc9555d5f97328070c467f3663cc489aad130f28c42f35bf88c571920ab92acb8f75d03e35a75103c5bd96f061c96bd02af6e1d191b0dd164bc721377003edbf5d3ef65a5e9046385356b521623bee37f164850a0a7afb0ed4e7e8bd9afe1298f7d532bc9ad941812d332aece75d1cccb1ff69fd42b31f248ae579d9e0d6a14b0546e784ba940e32bd01c395df8ff4584040462b5479fa07336d503dc332e70fc06d9463297fc042b623d56f87efaa525a9b580e314d90d1211893ed407a26508deaa0a13c9ee8c902b9e1c3a02fe9a51452c02ee7bdcc85c0eff63891e24703bd265d9c9dbf456e2af9409538bce0fecc7ebab20266aaab06c766c3ea6cda9cb9ba5e1d024b7dc3d73e76f6a333197bad87c4fb34d565a0014aac72825e41adcfeadadc87acef40ad84b7c55691abad561be0550ea0a988470c427432acb8feb2b9d2d2598fb2089bb91bbd9cb199e892d36164d8bf3ecd54576a97134047a12da84207485bb4e5</span></span><br></pre></td></tr></table></figure><p>后面<code>0203</code>含义：<code>02</code>是分隔符，<code>03</code>表示后面3个字节为加密指数<code>e</code>，即<code>e=0x10001(65537)</code></p><p>接下来<code>02820380</code>：<code>02</code>是分隔符，<code>82</code>表示后面两个字节<code>0380</code>为参数<code>d</code>的长度，即<code>d.length=0x0380bytes</code>，显然<code>d</code>被损坏了</p><p>接下来<code>028181</code>：<code>02</code>是分隔符，<code>81</code>表示后面1个字节<code>81</code>为参数<code>p</code>的长度，即<code>p.length=0x81bytes</code>，题目只给出了<code>p</code>的高位</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p_high = <span class="number">0x008063d0a21876e5ce1e2101c20015529066ed9976882d1002a29efe0f2fdfcc2743fc9a4b5b651cc97108699eca2fb1f3d93175bae343e7c92e4a41c72d05e57019400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>同理：q的高位</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q_high = <span class="number">0x00e4f0fe49f9ae1492c097a0a988fa71876625fe4fce05b0204f1fdf43ec64b4dac699d28e166efdfc7562d19e58c3493d9100365cf2840b46c0f6ee8d964807170ff2c13c4eb8012ecab37862a3900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>p_high中已知的部分有524bit，满足p的高位攻击</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0x067f0aa4e974a63a1ffe8d5c23e5d3c431653ae41cc746f305f62a9f193f22486cb7ef1b275634818f46d0752a5139e19918271fa0d7d27bc660d2b72414d08ea52c8837f949c7baecc3029ba31727ef3bf120d9926c02d7412f187e98dc56dd07b987d2cc191ad56164a144f28b2f70a15d105588a4f27fbb2891fc527bd6890a5f795b5c48476a6bf9dfb67b7e1ebc7b1b086cd28b58c68955bfdf44ecce11ffacdf654551b159b7832040cc28ee8ebea48f8672d53e3de88fcfbb5fb276b503880dd34d5993335ddf8ccb96c1b4d79f502d72104765ad9c2b1858a17af3d5be44fa3cbf4b8eeb942aa3942a3871d2c65ac70289123fc2e9f9b25cbfcbd7841096060fa504c3a07b591493c64c88d0bb45285a85b5f7d59db98faa00c2cd3fbb63da599205f1cab0df52cf7b431a0ee4a7e35696546ce9d03ef595ecee92d2142c92e97d2744939703455b4c70dec27c321ec6b83c029622e83a9e0d55d0b258d95d4e61291865dda76dc619fce9577990429c6e77e9d40781e3b2f449701b83e8b0c6c66eb380f96473e5d422efee8b2b0e88b716b00a79c9d514ca3ad9d2dee526609ff9541732a4198d11b9dbfbb2e55c24d80ea522d0786e3355f23606a5d38a72de4eefc8b6bfc482248a2862cb69d8e0e3d316597da9d80828be85054faf15fc369caacafb815c6973c171940683d56a1a1967b09b7ffa3fbe5b2e08699759d84d71603f516447696bb27322a69f39f6ca253e00dc9555d5f97328070c467f3663cc489aad130f28c42f35bf88c571920ab92acb8f75d03e35a75103c5bd96f061c96bd02af6e1d191b0dd164bc721377003edbf5d3ef65a5e9046385356b521623bee37f164850a0a7afb0ed4e7e8bd9afe1298f7d532bc9ad941812d332aece75d1cccb1ff69fd42b31f248ae579d9e0d6a14b0546e784ba940e32bd01c395df8ff4584040462b5479fa07336d503dc332e70fc06d9463297fc042b623d56f87efaa525a9b580e314d90d1211893ed407a26508deaa0a13c9ee8c902b9e1c3a02fe9a51452c02ee7bdcc85c0eff63891e24703bd265d9c9dbf456e2af9409538bce0fecc7ebab20266aaab06c766c3ea6cda9cb9ba5e1d024b7dc3d73e76f6a333197bad87c4fb34d565a0014aac72825e41adcfeadadc87acef40ad84b7c55691abad561be0550ea0a988470c427432acb8feb2b9d2d2598fb2089bb91bbd9cb199e892d36164d8bf3ecd54576a97134047a12da84207485bb4e5</span></span><br><span class="line">c = <span class="number">145554802564989933772666853449758467748433820771006616874558211691441588216921262672588167631397770260815821197485462873358280668164496459053150659240485200305314288108259163251006446515109018138298662011636423264380170119025895000021651886702521266669653335874489612060473962259596489445807308673497717101487224092493721535129391781431853820808463529747944795809850314965769365750993208968116864575686200409653590102945619744853690854644813177444995458528447525184291487005845375945194236352007426925987404637468097524735905540030962884807790630389799495153548300450435815577962308635103143187386444035094151992129110267595908492217520416633466787688326809639286703608138336958958449724993250735997663382433125872982238289419769011271925043792124263306262445811864346081207309546599603914842331643196984128658943528999381048833301951569809038023921101787071345517702911344900151843968213911899353962451480195808768038035044446206153179737023140055693141790385662942050774439391111437140968754546526191031278186881116757268998843581015398070043778631790328583529667194481319953424389090869226474999123124532354330671462280959215310810005231660418399403337476289138527331553267291013945347058144254374287422377547369897793812634181778309679601143245890494670013019155942690562552431527149178906855998534415120428884098317318129659099377634006938812654262148522236268027388683027513663867042278407716812565374141362015467076472409873946275500942547114202939578755575249750674734066843408758067001891408572444119999801055605577737379889503505649865554353749621313679734666376467890526136184241450593948838055612677564667946098308716892133196862716086041690426537245252116765796203427832657608512488619438752378624483485364908432609100523022628791451171084583484294929190998796485805496852608557456380717623462846198636093701726099310737244471075079541022111303662778829695340275795782631315412134758717966727565043332335558077486037869874106819581519353856396937832498623662166446395755447101393825864584024239951058366713573567250863658531585064635727070458886746791722270803893438211751165831616861912569513431821959562450032831904268205845224077709362068478</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">p0 = <span class="number">0x008063d0a21876e5ce1e2101c20015529066ed9976882d1002a29efe0f2fdfcc2743fc9a4b5b651cc97108699eca2fb1f3d93175bae343e7c92e4a41c72d05e570194</span></span><br><span class="line">q0 = <span class="number">0x00e4f0fe49f9ae1492c097a0a988fa71876625fe4fce05b0204f1fdf43ec64b4dac699d28e166efdfc7562d19e58c3493d9100365cf2840b46c0f6ee8d964807170ff2c13c4eb8012ecab37862a39</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = ((p0&gt;&gt;<span class="number">2</span>)*<span class="number">2</span>^<span class="number">502</span>+x)^<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(f.small_roots(X = <span class="number">2</span>^(<span class="number">502</span>), beta = <span class="number">0.45</span>, epsilon = <span class="number">0.03</span>))</span><br></pre></td></tr></table></figure><p>得到p，后面就可以正常解RSA了</p><p>这里要说明一下，对于上面为什么p要位移2bit，这就是我在比赛的时候踩的坑（在这里卡了一晚上……还是树哥有经验）</p><p>因为<code>p</code>的已知部分</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0x008063d0a21876e5ce1e2101c20015529066ed9976882d1002a29efe0f2fdfcc2743fc9a4b5b651cc97108699eca2fb1f3d93175bae343e7c92e4a41c72d05e570194</span></span><br></pre></td></tr></table></figure><p>转为二进制后</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0b10000000011000111101000010100010000110000111011011100101110011100001111000100001000000011100001000000000000101010101001010010000011001101110110110011001011101101000100000101101000100000000001010100010100111101111111000001111001011111101111111001100001001110100001111111100100110100100101101011011011001010001110011001001011100010000100001101001100111101100101000101111101100011111001111011001001100010111010110111010111000110100001111100111110010010010111001001010010000011100011100101101000001011110010101110000000110010100</span></span><br></pre></td></tr></table></figure><p>最后的两位是0，不一定是已知的真实值，可能是损坏的值，所以要把这两个bit去掉再进行高位攻击</p><p>验证：最后得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">90158455407064353226740172256637847571736267390156796413259819366666851822735984542845914678308585714535762114331991779976105574125437982741541925319918477642851700979718859437613437250733519320418663913659250175079815430032463049804595241254755873838742300889891959766753209758679639806589383714664811420277</span></span><br><span class="line"><span class="built_in">bin</span>(p) = <span class="number">0b1000000001100011110100001010001000011000011101101110010111001110000111100010000100000001110000100000000000010101010100101001000001100110111011011001100101110110100010000010110100010000000000101010001010011110111111100000111100101111110111111100110000100111010000111111110010011010010010110101101101100101000111001100100101110001000010000110100110011110110010100010111110110001111100111101100100110001011101011011101011100011010000111110011111001001001011100100101001000001110001110010110100000101111001010111000000011001011000001100100111000010111001100110101000111010111111110010011010111101001011000010011001011000011010101000010100000001111111111010101100000101010001000001110111111101110100100101110110100010110110110011111010010011110100100001001110000001111001000100001111001001000101110111001001011101011110010110000101000100010011111001110010101110101010010110101011111110000111111010010110100110010011001001101010010011000001001010101010001101100010001011001100011010110011010100101100100111000001010101101001110101</span></span><br></pre></td></tr></table></figure><p>可以发现：那两位bit是<code>10</code>而不是<code>00</code>，说明<code>p_high</code>最后这两个bit位确实不是真实值</p><p>吸取这次教训，以后高位攻击是先转成二进制看看最后面的bit位，如果是<code>0</code>，要添加位移</p><h3 id="3-whisper">3. Whisper</h3><p>hint: Two public key certificates were monitored. And Mr. Dual intercepted a ciphertext. Just when he was in the rough, a Careless Whisper told that the length of a key parameter is carelessly set to 345 bits.</p><p>给了两个公钥文件和一个加密文件</p><p>用openssl读取一下，得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N1 = <span class="number">19216005446310864558409934096148904703198882317083224129431545386380435777354723744624028053518278514595663319253560114239018542660582960464010994454707936550902872627309424890333127288994449006783158078916602020794628546065674981593736606481809198149080696037584037699638293870122512237711498004090515845499</span></span><br><span class="line">N2 = <span class="number">4992911943798277344804876549224813326447469267517432903838084455752417287982320183584988170455130118418117937196562948710115292838538880218156469801938645463822391931977946975012481667095710882823897026534267366981015926659114785262116088548568215969555191689632109516970297562458267207338397574333407150103</span></span><br><span class="line">e = <span class="number">5352708372343813403035593638037107517373724079700735571091908193413083617555211472255125798199165859811237950085789893649651552088125747433480591652396404710788778815075048587264350078253899425987466937040099316084273123603046629945048298154353920118466252136326911019666012632927688983695457057246503276867</span></span><br><span class="line">c = <span class="number">15215414324218119514166856548319827087347975479953435757551380183481824597666586239577164581282639891207362199632694698810120856780147289618566227285967212830337320315326701453355443595245474646348352728630245065334265985318506260363891869088324717641979951184093710784542525865784982264295576662469010725462</span></span><br></pre></td></tr></table></figure><blockquote><p>Dual RSA是一种由Sun等人在2007年提出的RSA变体，其主要特点是两个实例共享相同的公钥和私钥指数，但具有不同的模数。这种设计的主要优势在于减少了存储需求，因为只需要存储一套公钥和私钥即可处理两个不同的RSA实例。</p></blockquote><p><a href="https://hasegawaazusa.github.io/dual-rsa-note.html">Dual RSA——双生RSA，对偶RSA | 独奏の小屋 (hasegawaazusa.github.io)</a></p><p>这个知识点在 61dctf 和 0ctf-2017-final 出现过</p><p>看了关于低解密指数Dual RSA的exp都来自 [Authentication&amp;Secrecy (Crypto 1000pts) - MDWiki (<a href="http://elliptic-shiho.github.io">elliptic-shiho.github.io</a>)](<a href="https://elliptic-shiho.github.io/ctf-writeups/#!ctf/2017/0CTF">https://elliptic-shiho.github.io/ctf-writeups/#!ctf/2017/0CTF</a> Finals/cr1000-AuthenticationSecrecy/README.md)</p><p>代码来自：<a href="https://blog.wm-team.cn/index.php/archives/82/#Whisper">SCTF 2024 By W&amp;M - W&amp;M Team (wm-team.cn)</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_overview</span>(<span class="params">BB</span>):</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = <span class="string">f&#x27;<span class="subst">&#123;ii:02d&#125;</span> &#x27;</span></span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">&#x27; &#x27;</span> <span class="keyword">if</span> BB[ii, jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dual_rsa_liqiang_et_al</span>(<span class="params">e, n1, n2, delta, mm, tt</span>):</span><br><span class="line">    N = (n1 + n2) // <span class="number">2</span></span><br><span class="line">    A = ZZ(math.floor(N**<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">    _XX = ZZ(math.floor(N**delta))</span><br><span class="line">    _YY = ZZ(math.floor(N**<span class="number">0.5</span>))</span><br><span class="line">    _ZZ = ZZ(math.floor(N**(delta - <span class="number">1.</span>/<span class="number">4</span>)))</span><br><span class="line">    _UU = _XX * _YY + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    M = Matrix(ZZ, [[A, e], [<span class="number">0</span>, n1]])</span><br><span class="line">    B = M.LLL()</span><br><span class="line">    l11, l12 = B[<span class="number">0</span>]</span><br><span class="line">    l21, l22 = B[<span class="number">1</span>]</span><br><span class="line">    l_11 = ZZ(l11 // A)</span><br><span class="line">    l_21 = ZZ(l21 // A)</span><br><span class="line"></span><br><span class="line">    modulo = e * l_21</span><br><span class="line">    F = Zmod(modulo)</span><br><span class="line"></span><br><span class="line">    PR = PolynomialRing(F, <span class="string">&#x27;u, x, y, z&#x27;</span>)</span><br><span class="line">    u, x, y, z = PR.gens()</span><br><span class="line"></span><br><span class="line">    PK = PolynomialRing(ZZ, <span class="string">&#x27;uk, xk, yk, zk&#x27;</span>)</span><br><span class="line">    uk, xk, yk, zk = PK.gens()</span><br><span class="line"></span><br><span class="line">    PQ = PK.quo(xk * yk + <span class="number">1</span> - uk)</span><br><span class="line">    f = PK(x * (n2 + y) - e * l_11 * z + <span class="number">1</span>)</span><br><span class="line">    fbar = PQ(f).lift()</span><br><span class="line"></span><br><span class="line">    gijk = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(mm + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mm - k + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(mm - k - i + <span class="number">1</span>):</span><br><span class="line">                gijk[i, j, k] = PQ(xk**i * zk**j * PK(fbar)**k * modulo**(mm - k)).lift()</span><br><span class="line"></span><br><span class="line">    hjkl = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(math.floor(mm / tt) * j, mm + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>):</span><br><span class="line">                hjkl[j, k, l] = PQ(yk**j * zk**(k - l) * PK(fbar)**l * modulo**(mm - l)).lift()</span><br><span class="line"></span><br><span class="line">    monomials = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> gijk.keys():</span><br><span class="line">        monomials += gijk[k].monomials()</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> hjkl.keys():</span><br><span class="line">        monomials += hjkl[k].monomials()</span><br><span class="line"></span><br><span class="line">    monomials = <span class="built_in">sorted</span>(<span class="built_in">set</span>(monomials), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(monomials) == <span class="built_in">len</span>(gijk) + <span class="built_in">len</span>(hjkl)</span><br><span class="line">    dim = <span class="built_in">len</span>(monomials)</span><br><span class="line"></span><br><span class="line">    M = Matrix(ZZ, dim)</span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> gijk.keys():</span><br><span class="line">        <span class="keyword">for</span> i, monomial <span class="keyword">in</span> <span class="built_in">enumerate</span>(monomials):</span><br><span class="line">            M[row, i] = gijk[k].monomial_coefficient(monomial) * monomial.subs(uk=_UU, xk=_XX, yk=_YY, zk=_ZZ)</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> hjkl.keys():</span><br><span class="line">        <span class="keyword">for</span> i, monomial <span class="keyword">in</span> <span class="built_in">enumerate</span>(monomials):</span><br><span class="line">            M[row, i] = hjkl[k].monomial_coefficient(monomial) * monomial.subs(uk=_UU, xk=_XX, yk=_YY, zk=_ZZ)</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    matrix_overview(M)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    B = M.LLL()</span><br><span class="line"></span><br><span class="line">    matrix_overview(B)</span><br><span class="line"></span><br><span class="line">    H = &#123;i: <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim)&#125;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">            H[i] += PK((monomials[j] * B[i, j]) / monomials[j].subs(uk=_UU, xk=_XX, yk=_YY, zk=_ZZ))</span><br><span class="line">    H = <span class="built_in">list</span>(H.values())</span><br><span class="line"></span><br><span class="line">    PQ = PolynomialRing(QQ, <span class="string">&#x27;uq, xq, yq, zq&#x27;</span>)</span><br><span class="line">    uq, xq, yq, zq = PQ.gens()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">        H[i] = PQ(H[i].subs(uk=xk * yk + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    I = Ideal(*H[<span class="number">1</span>:<span class="number">20</span>])</span><br><span class="line">    g = I.groebner_basis(<span class="string">&#x27;giac&#x27;</span>)[::-<span class="number">1</span>]</span><br><span class="line">    mon = [t.monomials() <span class="keyword">for</span> t <span class="keyword">in</span> g]</span><br><span class="line"></span><br><span class="line">    PX = PolynomialRing(ZZ, <span class="string">&#x27;xs&#x27;</span>)</span><br><span class="line">    xs = PX.gen()</span><br><span class="line"></span><br><span class="line">    x_pol = y_pol = z_pol = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g)):</span><br><span class="line">        <span class="keyword">if</span> mon[i] == [xq, <span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(g[i] / g[i].lc())</span><br><span class="line">            x_pol = g[i] / g[i].lc()</span><br><span class="line">        <span class="keyword">elif</span> mon[i] == [yq, <span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(g[i] / g[i].lc())</span><br><span class="line">            y_pol = g[i] / g[i].lc()</span><br><span class="line">        <span class="keyword">elif</span> mon[i] == [zq, <span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(g[i] / g[i].lc())</span><br><span class="line">            z_pol = g[i] / g[i].lc()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x_pol <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> y_pol <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> z_pol <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[-] Failed: we cannot get a solution...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    x0 = x_pol.subs(xq=xs).roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    y0 = y_pol.subs(yq=xs).roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    z0 = z_pol.subs(zq=xs).roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> f(x0 * y0 + <span class="number">1</span>, x0, y0, z0) % modulo == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a0 = z0</span><br><span class="line">    a1 = (x0 * (n2 + y0) + <span class="number">1</span> - e * l_11 * z0) // (e * l_21)</span><br><span class="line"></span><br><span class="line">    d = a0 * l_11 + a1 * l_21</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    delta = <span class="number">0.334</span></span><br><span class="line">    mm = <span class="number">4</span></span><br><span class="line">    tt = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    n1 = <span class="number">0x1b5d4fe0aa6782e275d4ce12a6d57562efbbe7db6f5277255b891729bfa2a18d3edb49843d7989a37b9516be2df8ca939058e65f64b5fb2071bea4f5f8d1392895b32bf0377d99f4f79979125e5db01cdb5080a1c2d665c9ac31b5823025499c9513277bae5e7a846cd271c4396e2ba219020e58a9055cb18a28d36a00bf717b</span></span><br><span class="line">    e = <span class="number">0x079f5ccc665767b4a257e5c1ff56e9803df2e5650302daad420105fe672447743bd3f0bea1c46a4987932e9a886ca87a7afd7796abf1e5629c4986fe4f22e89cdce7abb06624465146a2e2b6ca9ab3196ceab7467974c1dc45608a200411b291fdaf99f7d80dce4db3566f4a9e2e574c6224cd07d80638d28f7820bcf4b49143</span></span><br><span class="line">    n2 = <span class="number">0x071c324e8769493187c15f72d5cc695729b48488ee3fbd01db00d5c478f08c7cf32093ba61745051d3e9d169523aa91438181f47679aff5edd22950f74a1eb1443320aaa5d97f5c1e81b5ef9a3e69ba669abc4c6c4b405f5088a603a74f9bcef88823b4523574114c810600838728196f8e5e0d4aeeeeab79dd8683a72f3c017</span></span><br><span class="line"></span><br><span class="line">    d = dual_rsa_liqiang_et_al(e, n1, n2, delta, mm, tt)</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><h3 id="4-lineararts">4.LinearARTs</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.groups.perm_gps.permgroup_named <span class="keyword">import</span> SymmetricGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Young</span>(<span class="params">FLAG</span>):</span><br><span class="line">    f = <span class="built_in">int</span>.from_bytes(FLAG, <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    q = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">while</span> f:</span><br><span class="line">        s.append(f % q)</span><br><span class="line">        f //= q</span><br><span class="line">    s = vector(GF(q), s)</span><br><span class="line"></span><br><span class="line">    n, m = <span class="built_in">len</span>(s), <span class="built_in">len</span>(s) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    A = Matrix(GF(q), m, n, <span class="keyword">lambda</span> i, j: randint(<span class="number">0</span>, q - <span class="number">1</span>))</span><br><span class="line">    e = vector(choices(<span class="built_in">range</span>(<span class="number">2</span>^<span class="number">8</span>), k=m), GF(q))*Matrix(ZZ,PermutationGroupElement(SymmetricGroup(m).random_element()).matrix())</span><br><span class="line">    b = (A*s) + e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A,b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Old</span>(<span class="params">m, nbits</span>):</span><br><span class="line">    Sn = SymmetricGroup(m)</span><br><span class="line">    p = [getPrime(<span class="number">360</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    N = <span class="built_in">sorted</span>([getRandomNBitInteger(nbits) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)])</span><br><span class="line">    S = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        r = [N[_] % p[i] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        r = vector(ZZ,r)</span><br><span class="line"></span><br><span class="line">        Per = Sn.random_element()</span><br><span class="line">        P = PermutationGroupElement(Per)</span><br><span class="line">        Pm = Matrix(ZZ,P.matrix())</span><br><span class="line">        r *= Pm</span><br><span class="line">        S.append(r)</span><br><span class="line">    S = matrix(ZZ,S)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Old.matrix&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(&#123;<span class="string">&quot;S&quot;</span>: <span class="built_in">str</span>(<span class="built_in">list</span>(S)),<span class="string">&quot;p&quot;</span>: <span class="built_in">str</span>(p)&#125;, f)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chall</span>(<span class="params">nn</span>):</span><br><span class="line">    <span class="comment"># The challenge lasted nn rounds</span></span><br><span class="line">    <span class="comment"># Young_level * virtue &gt;= Old_level , where virtue = nn + 1</span></span><br><span class="line"></span><br><span class="line">    h = []</span><br><span class="line">    HP = []</span><br><span class="line">    MP = []</span><br><span class="line">    Old_level = <span class="number">625</span>*<span class="number">2</span>*<span class="number">2</span></span><br><span class="line">    Young_level = <span class="number">25</span>*<span class="number">5</span>*<span class="number">5</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    M = getPrime(Old_level)</span><br><span class="line">    XP = getRandomRange(<span class="number">1</span>,M)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">        a = getRandomRange(<span class="number">1</span>,M)</span><br><span class="line">        b = a*XP % M</span><br><span class="line">        HP.append(a)</span><br><span class="line">        MP.append(b)</span><br><span class="line">        delta_level = Old_level - Young_level</span><br><span class="line">        h.append(b &gt;&gt; delta_level &lt;&lt; delta_level)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XP,M,HP,MP,h</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">mm = <span class="number">16</span></span><br><span class="line">nn = <span class="number">9</span></span><br><span class="line">nbits = <span class="number">3840</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A,b = Young(FLAG)</span><br><span class="line">N = Old(mm, nbits)</span><br><span class="line"></span><br><span class="line">XP,M,HP,MP,h = chall(nn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MP is useful ,I can use him to cast five lightning spells</span></span><br><span class="line">D = diagonal_matrix(GF(<span class="number">0x10001</span>),N+MP)</span><br><span class="line">Sn = SymmetricGroup(<span class="number">5</span>*<span class="number">5</span>)</span><br><span class="line">Per = Sn.random_element()</span><br><span class="line"></span><br><span class="line">P = PermutationGroupElement(Per)</span><br><span class="line">PM = Matrix(GF(<span class="number">0x10001</span>),P.matrix())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AA = A*D*PM</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D.matrix&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(&#123;<span class="string">&quot;D&quot;</span>: <span class="built_in">str</span>(<span class="built_in">list</span>(D))&#125;, f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># OK! Find your martial arts, and then you can get the flag.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(&#123;<span class="string">&quot;AA&quot;</span>: <span class="built_in">str</span>(<span class="built_in">list</span>(AA)), <span class="string">&quot;b&quot;</span>: <span class="built_in">str</span>(b)&#125;, f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;My SymmetricGroup is <span class="subst">&#123;Sn&#125;</span>, and my element is <span class="subst">&#123;Per&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;M = <span class="subst">&#123;M&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;h = <span class="subst">&#123;h&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;HP = <span class="subst">&#123;HP&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">My SymmetricGroup is Symmetric group of order 25! as a permutation group, and my element is (1,23,2,13,3,16,15,6,22,18,14,4,25,11,20,24,21,9,5,17,7,19,10,12,8)</span></span><br><span class="line"><span class="string">M = 309169501373330124045649100152326414225457160505584328527283516968464416389302355829097052128714780092162406614467026044744098784954762500832278190406881802198303575338158311874491341970444579146638248815636164413771772581964591833455055886833879504320098506335328910379223983277573694356846337961823081287986674791459748001014087760336006966850192999063236788568848765812192775492248445517060690151700498331622538367493718859724934115228375142396923937735633684527869745420378950550480692200706066019831688796077313463059296313396035429537407627377675974680696279162072713257960965681304091009329215383850223530139165455326927677102783057396241883175412729216204807235187239596365892879371542214145426492827777125727970815789114727245511828912252143569</span></span><br><span class="line"><span class="string">h = [3565625090222584896920916237461241765625829204082396377386021101162536812411479309464325956424849651112502540095796665989782448302150047491000013081443589381171861802823657878857754676608742927932812781165716659755896099505195018830422885342733139127785165794897376463794696074605473512720672450888626374504772116915620258088753289255996096552892614801083370595759624402874902282635442418547645823133641783382626721416313803991932439793168113855890150599332984583295219543856049901518912201443065300476561372304830840276820139993555523469165273121628823953454126151208689489078628524850757272649061955436843893289237414654732290904213005377463766762255194199607599718375650615493280298611532927519686558670313416090562438894368509350896602591065538560, 286740894693471986151090603562932147965458822098297907353215124508138484491994267754471216888566417392843923796488725160656461314962959042706124173470952968241147487040483767911639159119505992553207913863135028688626896196178757909088128827455625174341894140582939848620368540355056452428553556546413465430152617836247505772663758606552662729528340901377490256234099815707208769579251833692482247933846648593307680305448986314447242583396656418769737861680456297522358131674037354880608888487272985141452871763297604747444764332049229204365395410106847606241968638474099061876569990163879954288002836750959104349076854993248516655758322107956062243468530601256243967323153547535726777712582210098524981336526310800007425464476736381605758610129914167296, 202445786178968197828946112166667682571891905248793492278433983415264905988886412319222803698650008275405441752508434114212113517053913972304515710532012288036732448805044856628337036478357496484044773293960097063848568051250774170422935810965491124102107450786197166927290614807575403261921855599437944525251033428950982061449203659272914014109623656149839199935645660386382459896840619916225080206084500617856222897968865436783548821187873430635315967325778835200418210099836625362334832448337496843986398001079590846483593452928602841826412074751479179471599709999916393508418744578599831517548843854866251289525136765297969136698285441109232446206843977149859059568434871554288377088102779550812057943402777376610057499017696210394059743209313009664, 114630215368349491250326648494149748728124718005857201833657753308980378360823813480094685056650954220208569495921715772409260048257134505583210349697604470912610748671738387322753221966031149012764535612682778184882174392537951540598166408100353995693537007226929298573802177602978136134506604598926968767277963229517115896872176785224081721198822306288029114228955110090342800494317915814873698062519566559427796027618459996738296291782097320521350172532923653864250838232011730592925952612867718426259229217480911558421879422300001641170190840092379605603655701803649801243406059797147753118709730213303123683329677068533772082060407549189564758770771711148071596602056935716438347268248190581386987972757911856155781563899140822797888004226036006912, 128249367678574240079270694387429301574447189368221420750047602082333294620192478593526403955673394674124614483528399397766799072294205407818283464218350759458734269850052374022374583516046462573242829813776315162366850512131805663098817008453376098230770350796562755291771240680188153978483320771657621585572523650775437065002970862224206343896650474078023744187172724827284900132434561870157274624749481073656218832950661419154809116630241897087363941068977482336058825222409922455565132842885044852488100437379745993397785019888492704177085025661715401393223084613786993440233186999961708361656323625565518221228007812487647507152403406194060777071074419667727156839380340460479471882700515901974677682591933244024896502221255164137619867236474814464, 59331241745881917257932833661253483407124868132789104057434303748460794035055450167305496229505776497962206681068504038089886777631651664100577079680933516972657892279730519042800959265778075851643260975944157575808540832473360789304763830393990596483325556391563383526131388426655998362610795663009444329530380313582369506744601127066018505286584082074112032220681653032998814836135211241601616761559477125123260865574463289315537641250468595444847485104869371846138937594815717839233479424297762637589843061706537365341325349697086472650360732699495909942722893269089976271337217878676728476285757191230122449283410993290558727101211299826258005529280347023431637543174327095221833097882251371141896661614980087581376418853642047359092191718247759872, 194175487858295065586566223420720835354218714701012787036868166885106803179611016852320235121944886794854103233580220709024806072743993477154116046455972680314714490810103482613775169723949822599089353607462687446238694112422779778557153306320141326888706724709408146840971915646939721136724368012432988045478440516756541030644897102338343015620307071124895653986756365725579987250601332133147888516462970772662004254372283824275049130754409522022155104472953510056515893487814795314057133448327072939691256835996305152489881345263632544581620669637374642183724635278556621665654137071320546871015687481523597402928763713183489458838102245889150936728919959706046092027960728825776566021949524779914956226078468441681639597976295123311554992063660425216, 115807966653135071136266364151575193370063353963428994232152558690537462513652457844803096649471511022423130391640990718769139833768597282872892832632006932256100725142377601958457582836326282142674470340977659300588249614977457789078637672424804434580082554677223019302922992562279282682989740074843377451539592513262883913515900320935326048141177654658002842824967867990878423576079246988742657580816398545604320575322509216636723893917401586976250940528255869144608693606581992658961868351662299980182039083401570931369157275822911645710245831972301615048181855392924402552747776587682847866506513589721569586179062186510923857682304736484524409943982860419833114775174973677241133994963586243092033231181717755422868113246798964708435895447826989056, 35892864763676162390876495832131732661057713103645821857653105944898881372368808709419507620431545862639883539544774550258981962490994311035563824804791343118179784911204081384298523734092852978345353083620780025983844560713535542579917199852557029443606552741189260726705956142592472777625642697686483587065598383553745177190736612246797880186504227507540789056735743669295160656843457591270441961646851151123270490417727787782300206183313402455683157806373799412772262389178947152383087432869175216907112201344491993073522598897459497720231382736974467891671184580545749653915968971302794570679028312275641136161418552643700105215949462752782765599606395043723535992514850129235084780569665298381129831228968986167487292913320768400938041503014453248]</span></span><br><span class="line"><span class="string">HP = [182123398439336131233484419016500805950625530876289136147992418330368556518782504528500478328506268530182121028338611308706301778495117293952384271741141930454826813234222655694969514594179399691491676343267560926415204796892285953757083137635724586246679285504584200603423040990857955982592545447321735123888380669252758270022750955484747603018957220340523162322224297824154306196315662236519394066376582303992842999145368668536271548561974662730580382535581064544751603313110317522142473855128127879421866476758202400277448627166191464212616826131845112048518089279156877724351779259697512559047606602356481432326384500230304234630224805224043299183292854524931957718694768306272627669496947333830650701612740067754226344379590044087735385490127725862, 143170049879066655087340950742576943114220056125957541251904657597420632960015895981469092773424062349481612793313849969949143634455140221504418524950906026552571808412365313452770620316647140315635576351924131570731151371864300979486246561311374091503771233474221846682477948158595874825046725186096019808916856990568087679235183223125111635340379631262792582193894921427748477534899648278496684573736979116799130367368459501772350225298850161734598992871658808303947946703790369232633550983464071710073626283163523659905448412753809088559015473221667463885047754120012784534383142422681768521744011385759111784771218858429141270195947803513052066866898605116497618560152428747336114471742600059289342252682494024257280492765302681978041917175224445454, 181932081065216017223259767432026159751069100962417675256904857171174594214631105569878401257202843288868067795959660425655397502682572819329811836847256980387967545675607257191386494389870983892416162767006265255985611267066664459013834260578459679814704254643652527448346657946799415019242620362556994094217501805852227552561431064112972359577708305419407712233651342990435225577864469921706228376386943352990854043536613387681781610381704457332320684886669558444649325853462867815167473502469305672972117003639658784729134706896312010708005781941993559519054971159338636279746679220293668476785752715272037394473281514117697060980377364913173031572794672785720241295564153405600993322639561228795731008971285970805298272968367327982292736365952177736, 152197501838094386559667505260111556746524794647762036036984156853293482749405051706379215782024625767996604204199239858042655575156447769644733342469940464962491758196879181740442958683860120188153222622045687386550968060691333980045707578681522952010130720785366069103645756481641865768541014660604224000448808608848607142992914438243019336580286597455942208546183871629991237012627078724041815698483916930337697145596477943636313719062754662224057190310995369364817444976298713991954316505112491477110025799278176478205958831032614361098570277711286905522504386261323350696026797810604096448605140635754896533192146402989175530945145957561334345659035675075518654525640506611082619111666729303712983450765181951782352125875791130477959487243678637091, 13260127114160132039578764564277724908293717164091148143281881592450508800268944502885346275659282139962084615098549527321116911955505649119891798866789702019684393024690093331965422247341532921411724247274538089836518071897735012248880718279028139698315282234778842097294789834605571276706239190589177804771135138639650083317735678737873354475068162084129555751126946723880482765306519620594499615623179141020788167278111494656031619604249830332631535459164808166638124806843052957919064456863967475953053614347964520430672883482509352453640521720313380086324061829310129198351733197836811498655541708077300463414261809122652381872563486116022996781876662952751320598808796685963865092538114154484684417346701057121540968905340884852819266786655758589, 7726965701613058376939617426173930484905424609871511448979899585789330472291184137208473525618669017229437131718602138062693323242254540169837667647945751730728109543890184121875756549720616016417689684297714982752898170211522441794931085191911567142756874944612942983995000585648922927662513704308624388978740497618316239028274910398075357992565743563209649419566296437582035744561981287334953927069851636537379718348745797306743042426246174030053256711319421877929342022143063981126785133505358707977994735220823800241921524140116409926290245600210702333580796340264633188699655847265231481741281891892263047439742010063674785264961945504178892794083333407945969304699309469264200568906760592035714702098416830232068808480043043046899584880476365211, 180019050945153380400290419089497765220330628588910896281952550416089875088850281952204916892735263785902815673400396668990373595469072648699918494008065197996354855591310768398651316061183602708507734278231600299784123286043254063248471261126675877896352754705297219631260970186401862696837291306580096200621090959901083133979809165850290006958174043988594120292941019793669119321273860506863788556691180109910206811333775009617945993184652622929206661236756401337666271307645630166144277622050610823301758570383783302397752531144991093835433241988398747399949918853848203882961092951831645541246295873588649289531107814613167236073250185453276804880016561013769084225682634383784489652871867815664211238325551136693769474979447466046146633345857611195, 153629149463789849413429112784055293255734339122176408662359601604336509143473758509975758863274395783633189549584941125392600362702091233425733911049553699926215208790821097092121122480643207790283486114884596194662369389215802952635756543090033023067139610689568413680910122744788001731552268160061684744631583107942765508030881967516350806276166348479082293252825499156766363138008724860360262292088895234376252334258828427316419408016153682496909981178280572676774045522450227853270448821337580837554794712541359286413423248459963738684095208415746808201768526760043282181933350859027227907243501251390338333188167931974689538439823388790515993422873395205982049903304374197483641428361419371833919139638015039992779119950859870347438758668679332495, 276427336329209668688130277925589460360311327851014652110707325284581770430564994121969230515633704248812997375123175470056237355182594647858048847262042361717893313893682161435196235153101006253340527909451448103893104917041136181377802230394106849393237486928849495116195885563734324888330607632821513438897200091110205098807840437587357564885934968344589488833398453563587665373858111713149172110412979734635024012258145628247175689960363707897865274630069427102722542299814253018238192096822853168130596686909789751383470674093768125446566821380042192204089190375373896356618809538058749144194802493153530124585829617231928160073305696376878930156414497547968857648212679322981790227182840452493558367673102471438871220031633314842129410346869161197]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WriteUP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PatriotCTF 2024 Crypto Writeup</title>
      <link href="/post/11600/"/>
      <url>/post/11600/</url>
      
        <content type="html"><![CDATA[<h2 id="patriotctf-2024-crypto-writeup">PatriotCTF 2024 Crypto Writeup</h2><p>Author: <em>dawn1ight</em></p><p>About: PatriotCTF is a beginner-friendly capture-the-flag competition hosted by GMU’s cybersecurity club, MasonCC. All are welcome to participate, including students and security professionals. Challenges will range from beginner to expert, so there should be something for everyone. This is a jeopardy-style CTF, meaning there will be various challenges from the different categories described below.</p><p>Challenges：<a href="https://pctf.competitivecyber.club/challenges">https://pctf.competitivecyber.club/challenges</a></p><p>Reference:</p><ul><li><a href="https://blog.csdn.net/weixin_52640415/article/details/142500402">https://blog.csdn.net/weixin_52640415/article/details/142500402</a></li><li><a href="https://www.ctfiot.com/206569.html">https://www.ctfiot.com/206569.html</a></li><li><a href="https://s19ma.github.io/posts/PatriotCTF/">https://s19ma.github.io/posts/PatriotCTF/</a></li></ul><h3 id="1-bigger-is-better">1. Bigger is Better</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">0xa0d9f425fe1246c25b8c3708b9f6d7747dd5b5e7f79719831c5cbe19fb7bab66ed62719b3fc6090120d2cfe1410583190cd650c32a4151550732b0fc97130e5f02aa26cb829600b6ab452b5b11373ec69d4eaae6c392d92da8bcbea85344af9d4699e36fdca075d33f58049fd0a9f6919f3003512a261a00985dc3d9843a822974df30b81732a91ce706c44bde5ff48491a45a5fa8d5d73bba5022af803ab7bd85250e71fc0254fcf078d21eaa5d38724014a85f679e8a7a1aad6ed22602465f90e6dd8ef95df287628832850af7e3628ad09ff90a6dbdf7a0e6d74f508d2a6235d4eae5a828ac95558bbdf72f39af5641dfe3edb0cdaab362805d926106e2af</span></span><br><span class="line">e = <span class="number">0x5af5dbe4af4005564908a094e0eabb0a921b7482483a753e2a4d560700cb2b2dc9399b608334e05140f54d90fcbef70cec097e3f75395d0c4799d9ec3e670aca41da0892a7b3d038acb7a518be1ced8d5224354ce39e465450c12be653639a8215afb1ba70b1f8f71fc1a0549853998e2337604fca7edac67dd1e7ddeb897308ebf26ade781710e6a2fe4c533a584566ea42068d0452c1b1ecef00a781b6d31fbab893de0c9e46fce69c71cefad3119e8ceebdab25726a96aaf02a7c4a6a38d2f75f413f89064fef14fbd5762599ca8eb3737122374c5e34a7422ea1b3d7c43a110d3209e1c5e23e4eece9e964da2c447c9e5e1c8a6038dc52d699f9324fd6b9</span></span><br><span class="line">c = <span class="number">0x731ceb0ac8f10c8ff82450b61b414c4f7265ccf9f73b8e238cc7265f83c635575a9381aa625044bde7b34ad7cce901fe7512c934b7f6729584d2a77c47e8422c8c0fe2d3dd12aceda8ef904ad5896b971f8b79048e3e2f99f600bf6bac6cad32f922899c00fdc2d21fcf3d0093216bfc5829f02c08ba5e534379cc9118c347763567251c0fe57c92efe0a96c8595bac2c759837211aac914ea3b62aae096ebb8cb384c481b086e660f0c6249c9574289fe91b683609154c066de7a94eafa749c9e92d83a9d473cc88accd9d4c5754ccdbc5aa77ba9a790bc512404a81fc566df42b652a55b9b8ffb189f734d1c007b6cbdb67e14399182016843e27e6d4e5fca</span></span><br></pre></td></tr></table></figure><p>大加密指数e，经典wiener攻击</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> RSAwienerHacker.RSAwienerHacker <span class="keyword">import</span> hack_RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">n = <span class="number">0xa0d9f425fe1246c25b8c3708b9f6d7747dd5b5e7f79719831c5cbe19fb7bab66ed62719b3fc6090120d2cfe1410583190cd650c32a4151550732b0fc97130e5f02aa26cb829600b6ab452b5b11373ec69d4eaae6c392d92da8bcbea85344af9d4699e36fdca075d33f58049fd0a9f6919f3003512a261a00985dc3d9843a822974df30b81732a91ce706c44bde5ff48491a45a5fa8d5d73bba5022af803ab7bd85250e71fc0254fcf078d21eaa5d38724014a85f679e8a7a1aad6ed22602465f90e6dd8ef95df287628832850af7e3628ad09ff90a6dbdf7a0e6d74f508d2a6235d4eae5a828ac95558bbdf72f39af5641dfe3edb0cdaab362805d926106e2af</span></span><br><span class="line">e = <span class="number">0x5af5dbe4af4005564908a094e0eabb0a921b7482483a753e2a4d560700cb2b2dc9399b608334e05140f54d90fcbef70cec097e3f75395d0c4799d9ec3e670aca41da0892a7b3d038acb7a518be1ced8d5224354ce39e465450c12be653639a8215afb1ba70b1f8f71fc1a0549853998e2337604fca7edac67dd1e7ddeb897308ebf26ade781710e6a2fe4c533a584566ea42068d0452c1b1ecef00a781b6d31fbab893de0c9e46fce69c71cefad3119e8ceebdab25726a96aaf02a7c4a6a38d2f75f413f89064fef14fbd5762599ca8eb3737122374c5e34a7422ea1b3d7c43a110d3209e1c5e23e4eece9e964da2c447c9e5e1c8a6038dc52d699f9324fd6b9</span></span><br><span class="line">c = <span class="number">0x731ceb0ac8f10c8ff82450b61b414c4f7265ccf9f73b8e238cc7265f83c635575a9381aa625044bde7b34ad7cce901fe7512c934b7f6729584d2a77c47e8422c8c0fe2d3dd12aceda8ef904ad5896b971f8b79048e3e2f99f600bf6bac6cad32f922899c00fdc2d21fcf3d0093216bfc5829f02c08ba5e534379cc9118c347763567251c0fe57c92efe0a96c8595bac2c759837211aac914ea3b62aae096ebb8cb384c481b086e660f0c6249c9574289fe91b683609154c066de7a94eafa749c9e92d83a9d473cc88accd9d4c5754ccdbc5aa77ba9a790bc512404a81fc566df42b652a55b9b8ffb189f734d1c007b6cbdb67e14399182016843e27e6d4e5fca</span></span><br><span class="line">d = hack_RSA(e,n)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="2-idk-cipher">2. idk cipher</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">********************************************</span></span><br><span class="line"><span class="string">*                                          *</span></span><br><span class="line"><span class="string">*                                          *</span></span><br><span class="line"><span class="string">********************************************</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># WARNING: This is a secret key. Do not expose it.</span></span><br><span class="line">srt_key = <span class="string">&#x27;secretkey&#x27;</span> <span class="comment"># // <span class="doctag">TODO:</span> change the placeholder</span></span><br><span class="line">usr_input = <span class="built_in">input</span>(<span class="string">&quot;\t:&quot;</span>*<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(usr_input) &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;PT must be greater than 1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(usr_input) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;PT can only be an even number&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> usr_input.isalnum():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Only alphabets and numbers supported&quot;</span>)</span><br><span class="line"><span class="comment"># WARNING: Reversing input might expose sensitive information.</span></span><br><span class="line">rsv_input = usr_input[::-<span class="number">1</span>]</span><br><span class="line">output_arr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">len</span>(usr_input) / <span class="number">2</span>)):</span><br><span class="line">    c1 = <span class="built_in">ord</span>(usr_input[i])</span><br><span class="line">    c2 = <span class="built_in">ord</span>(rsv_input[i])</span><br><span class="line">    enc_p1 = <span class="built_in">chr</span>(c1 ^ <span class="built_in">ord</span>(srt_key[i % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    enc_p2 = <span class="built_in">chr</span>(c2 ^ <span class="built_in">ord</span>(srt_key[i % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    output_arr.append(enc_p1)</span><br><span class="line">    output_arr.append(enc_p2)</span><br><span class="line"><span class="comment"># WARNING: Encoded text should not be decoded without proper authorization.</span></span><br><span class="line">encoded_val = <span class="string">&#x27;&#x27;</span>.join(output_arr)</span><br><span class="line">b64_enc_val = base64.b64encode(encoded_val.encode())</span><br><span class="line">R = <span class="string">&quot;R&quot;</span>*<span class="number">20</span></span><br><span class="line">E = <span class="string">&quot;E&quot;</span>*<span class="number">5</span></span><br><span class="line">EXCLAMATION = <span class="string">&quot;!&quot;</span>*<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ULTRA SUPE<span class="subst">&#123;R&#125;</span> SECUR<span class="subst">&#123;E&#125;</span> Encoded Cipher Text<span class="subst">&#123;EXCLAMATION&#125;</span>:&quot;</span>, b64_enc_val.decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串加密，对加密脚本逆向可得解密脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">srt_key = <span class="string">&#x27;secretkey&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设这是从上面的加密脚本中得到的Base64编码的字符串</span></span><br><span class="line">b64_enc_val = <span class="string">&quot;QRVWUFdWEUpdXEVGCF8DVEoYEEIBBlEAE0dQAURFD1I=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码Base64字符串</span></span><br><span class="line">encoded_val = base64.b64decode(b64_enc_val).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密过程</span></span><br><span class="line">decoded_arr1 = []</span><br><span class="line">decoded_arr2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encoded_val), <span class="number">2</span>):</span><br><span class="line">    c1 = <span class="built_in">ord</span>(encoded_val[i])</span><br><span class="line">    c2 = <span class="built_in">ord</span>(encoded_val[i + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用相同的密钥对字符进行异或操作</span></span><br><span class="line">    dec_p1 = <span class="built_in">chr</span>(c1 ^ <span class="built_in">ord</span>(srt_key[i // <span class="number">2</span> % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    dec_p2 = <span class="built_in">chr</span>(c2 ^ <span class="built_in">ord</span>(srt_key[i // <span class="number">2</span> % <span class="built_in">len</span>(srt_key)]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加解密后的字符到数组中</span></span><br><span class="line">    decoded_arr1.append(dec_p1)</span><br><span class="line">    decoded_arr2.append(dec_p2)</span><br><span class="line"></span><br><span class="line">first_half = decoded_arr1</span><br><span class="line">second_half = decoded_arr2[::-<span class="number">1</span>]  <span class="comment"># 反转第二部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两部分得到最终解密结果</span></span><br><span class="line">usr_input = <span class="string">&#x27;&#x27;</span>.join(first_half + second_half)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Input:&quot;</span>, usr_input)</span><br></pre></td></tr></table></figure><h3 id="3-high-roller">3. High Roller</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3.10</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">random.seed(<span class="built_in">int</span>(time.time()))</span><br><span class="line">p, q = getPrime(<span class="number">512</span>, random.randbytes), getPrime(<span class="number">512</span>, random.randbytes)</span><br><span class="line">n = p*q</span><br><span class="line">e = getPrime(<span class="number">512</span>)</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> GCD(e, phi) == <span class="number">1</span></span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line"></span><br><span class="line">key = RSA.construct((n, e, d, p, q))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;public_key.pem&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(key.publickey().export_key(<span class="string">&quot;PEM&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;private_key.pem&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(key.export_key(<span class="string">&quot;PEM&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIHdMA0GCSqGSIb3DQEBAQUAA4HLADCBxwKBgQCMdauT2revYJrutp7eqQfrMkse</span><br><span class="line">TqfgRdLlMddaVRxiG04qJneVtpzkeLQTZqniJWx5YsUwMDeISeQjmVkr2a+Ob9S8</span><br><span class="line">+xsqVQ0XTW3xPjwKaZhW8jXAlX13ClhAxk1FvPbl6ASsPGUMX6gRSXArRYFx3Kev</span><br><span class="line">C9xng/ZKEhsC5FzBBwJBALKsZCm9FGHXvyJChFDt7vDZUCyU1jbOgS9EhNz+HrrU</span><br><span class="line">K9OCgOoZGfcjIHAcrM+w4AdF48NQELqttmKlcko6ock=</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>openssl读取公钥</p><p><code>openssl rsa -pubin -in public.pem</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">9357885447383373532894895505085381556066479232870333782284357317530689434635519527644215046975239651802146048650000941858355721661518511867620441456288201</span></span><br><span class="line">n = <span class="number">98634120039089098694716541094010585689286433311349526663366541706397717606400616707193452046001090589663396231287196347120718771479123852243352063594083947086372781079441835003204477521976780690108126553882967223715412003897334440698277808850595475155858935951484345749354296015842014107721137899755292901639</span></span><br></pre></td></tr></table></figure><p>提取出了n,e，但分解不出来</p><p>注意到<code>random.seed(int(time.time()))</code></p><blockquote><p>The seed was used is <code>int(time.time())</code> and converted into .pem file so we can use command to find time</p><p>给了公钥和p,q的生成方法，是用时间作种子，求利用random来求的。根据题目文件的时间向前可以爆破出来。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stat -c &#x27;%n %y&#x27; public_key.pem</span><br></pre></td></tr></table></figure><p>看这里复习一下stat命令 <a href="https://blog.csdn.net/u012294618/article/details/72630092">https://blog.csdn.net/u012294618/article/details/72630092</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pubkey = RSA.import_key(<span class="built_in">open</span>(<span class="string">&quot;public_key.pem&quot;</span>, <span class="string">&quot;r&quot;</span>).read())</span><br><span class="line">c = bytes_to_long(<span class="built_in">open</span>(<span class="string">&quot;flag.enc&quot;</span>, <span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">time_i = <span class="built_in">int</span>(time.mktime((<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(time_i, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    random.seed(i)</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>, random.randbytes), getPrime(<span class="number">512</span>, random.randbytes)</span><br><span class="line">    <span class="keyword">if</span> p*q == pubkey.n:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">pow</span>(pubkey.e, -<span class="number">1</span>, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, pubkey.n)))</span><br></pre></td></tr></table></figure><h3 id="4-textbook-schnorr-right">4. Textbook Schnorr right??</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EllipticCurveCrypto</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Elliptic Curve Cryptography using the secp256k1 curve.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.p = [&lt;REDACTED&gt;]</span><br><span class="line">        self.q = [&lt;REDACTED&gt;]</span><br><span class="line">        self.K = GF(self.p)</span><br><span class="line">        self.a = self.K([&lt;REDACTED&gt;])</span><br><span class="line">        self.b = self.K([&lt;REDACTED&gt;])</span><br><span class="line">        self.curve = EllipticCurve(self.K, [self.a, self.b])</span><br><span class="line">        self.generator = self.curve(</span><br><span class="line">            [&lt;REDACTED&gt;],</span><br><span class="line">            [&lt;REDACTED&gt;],</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># Generate private and public keys</span></span><br><span class="line">        self.private_key = secrets.randbelow(self.q)</span><br><span class="line">        self.public_key = self.private_key * self.generator</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Public Key: <span class="subst">&#123;self.public_key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bytes_to_int</span>(<span class="params">b</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(b, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">int_to_bytes</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">return</span> i.to_bytes((i.bit_length() + <span class="number">7</span>) // <span class="number">8</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_hash</span>(<span class="params">self, target</span>):</span><br><span class="line">        hash_int = <span class="built_in">int</span>(hashlib.sha256(<span class="built_in">str</span>(target).encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> hash_int % self.q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, message</span>):</span><br><span class="line">        r = secrets.randbelow(self.q)</span><br><span class="line">        R = r * self.generator</span><br><span class="line">        R_int = <span class="built_in">int</span>(R.xy()[<span class="number">0</span>] + R.xy()[<span class="number">1</span>])</span><br><span class="line">        h = self.compute_hash(R_int | message)</span><br><span class="line">        s = (r + self.private_key * h) % self.q</span><br><span class="line">        <span class="keyword">return</span> s, R</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, message, signature</span>):</span><br><span class="line">        s, R = signature</span><br><span class="line">        R_int = <span class="built_in">int</span>(R.xy()[<span class="number">0</span>] + R.xy()[<span class="number">1</span>])</span><br><span class="line">        h = self.compute_hash(R_int | message)</span><br><span class="line">        left_side = s * self.generator</span><br><span class="line">        right_side = R + h * self.public_key</span><br><span class="line">        <span class="keyword">return</span> left_side == right_side</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeoutInput</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeoutError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Custom exception for input timeout.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timeout_handler</span>(<span class="params">signum, frame</span>):</span><br><span class="line">        <span class="keyword">raise</span> TimeoutInput.TimeoutError(<span class="string">&quot;Input timed out!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_input</span>(<span class="params">prompt, timeout=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get user input with a timeout.</span></span><br><span class="line"><span class="string">        :param prompt: The prompt to display to the user.</span></span><br><span class="line"><span class="string">        :param timeout: The time limit for input in seconds.</span></span><br><span class="line"><span class="string">        :return: The user&#x27;s input as a string.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Set the signal for a timeout</span></span><br><span class="line">        signal.signal(signal.SIGALRM, TimeoutInput.timeout_handler)</span><br><span class="line">        signal.alarm(timeout)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user_input = <span class="built_in">input</span>(prompt)</span><br><span class="line">            signal.alarm(<span class="number">0</span>)  <span class="comment"># Cancel the timer</span></span><br><span class="line">            <span class="keyword">return</span> user_input</span><br><span class="line">        <span class="keyword">except</span> TimeoutInput.TimeoutError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No input received within the time limit.&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_flag</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read and display the flag from the &#x27;flag.txt&#x27; file.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            flag = f.read().strip()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Congratulations! Your flag is: <span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Flag file not found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_message</span>(<span class="params">separator, words, signature, ecc_instance</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Verify the provided signature for the message constructed from words and separator.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    message_bytes = separator.join(word.encode() <span class="keyword">for</span> word <span class="keyword">in</span> words) + separator</span><br><span class="line">    message_int = <span class="built_in">int</span>.from_bytes(message_bytes, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> ecc_instance.verify(message_int, signature):</span><br><span class="line">        display_flag()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Verification failed.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Initialize the elliptic curve cryptography instance</span></span><br><span class="line">    ecc = EllipticCurveCrypto()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Test the signing and verification process</span></span><br><span class="line">    test_message = ecc.bytes_to_int(<span class="string">&quot;test&quot;</span>.encode())</span><br><span class="line">    s_test, R_test = ecc.sign(test_message)</span><br><span class="line">    <span class="keyword">assert</span> ecc.verify(test_message, (s_test, R_test))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Regular expression patterns for input validation</span></span><br><span class="line">    separator_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^[0-9a-fA-F]&#123;2&#125;$&#x27;</span>)</span><br><span class="line">    word_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^[0-9a-fA-F]&#123;6&#125;$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get separator input</span></span><br><span class="line">    separator_hex = TimeoutInput.get_input(<span class="string">&quot;Enter separator as a hex value (2 digits): &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> separator_pattern.<span class="keyword">match</span>(separator_hex):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid separator format.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    separator = <span class="built_in">bytes</span>.fromhex(separator_hex)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get words input</span></span><br><span class="line">    words_hex = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        prompt = <span class="string">f&quot;Enter 3-letter word <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> as a hex value (6 digits): &quot;</span></span><br><span class="line">        word_hex = TimeoutInput.get_input(prompt)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word_pattern.<span class="keyword">match</span>(word_hex):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Invalid word format.&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        words_hex.append(word_hex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        words = [<span class="built_in">bytes</span>.fromhex(word_hex).decode(<span class="string">&#x27;ascii&#x27;</span>) <span class="keyword">for</span> word_hex <span class="keyword">in</span> words_hex]</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid ASCII encoding in words.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>(<span class="built_in">len</span>(word) != <span class="number">3</span> <span class="keyword">for</span> word <span class="keyword">in</span> words):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Words must be 3-letter ASCII words.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get signature components</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        hex_x_R = <span class="built_in">input</span>(<span class="string">&quot;Enter the x-coordinate of signature R (in hex): &quot;</span>)</span><br><span class="line">        x_R = <span class="built_in">int</span>(hex_x_R, <span class="number">16</span>)</span><br><span class="line">        hex_y_R = <span class="built_in">input</span>(<span class="string">&quot;Enter the y-coordinate of signature R (in hex): &quot;</span>)</span><br><span class="line">        y_R = <span class="built_in">int</span>(hex_y_R, <span class="number">16</span>)</span><br><span class="line">        hex_signature_s = <span class="built_in">input</span>(<span class="string">&quot;Enter signature s (in hex): &quot;</span>)</span><br><span class="line">        signature_s = <span class="built_in">int</span>(hex_signature_s, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid input for signature components.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt; signature_s &lt; ecc.q):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Illegal value of s.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the point R</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        R = ecc.curve(x_R, y_R)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Point R does not lie on the curve.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Verify the message and signature</span></span><br><span class="line">    verify_message(separator, words, (signature_s, R), ecc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这个题用了schnorr-digital-signature数字签名算法</p><p>它是将经典的<a href="https://www.geeksforgeeks.org/schnorr-digital-signature/">schnorr数字签名算法</a>移到secp256k1椭圆曲线上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 经典Schnorr签名算法</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个大素数 p 和它的大素因子 q</span></span><br><span class="line">p = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000001</span>  <span class="comment"># 一个大素数</span></span><br><span class="line">q = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span>  <span class="comment"># 大素因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个原根 g</span></span><br><span class="line">g = <span class="number">2</span>  <span class="comment"># 通常选择 2 作为原根</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名者的私钥 a 和公钥 A</span></span><br><span class="line">a = random.randint(<span class="number">1</span>, q - <span class="number">1</span>)  <span class="comment"># 私钥 a</span></span><br><span class="line">A = <span class="built_in">pow</span>(g, a, p)  <span class="comment"># 公钥 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希函数 H</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_message</span>(<span class="params">message, x</span>):</span><br><span class="line">    combined = <span class="string">f&quot;<span class="subst">&#123;message&#125;</span><span class="subst">&#123;x&#125;</span>&quot;</span>.encode()</span><br><span class="line">    h = hashlib.sha256(combined).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(h, <span class="number">16</span>) % q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">message, a, g, p, q</span>):</span><br><span class="line">    r = random.randint(<span class="number">1</span>, q - <span class="number">1</span>)  <span class="comment"># 随机数 r</span></span><br><span class="line">    X = <span class="built_in">pow</span>(g, r, p)  <span class="comment"># 计算 X</span></span><br><span class="line">    e = hash_message(message, X)  <span class="comment"># 计算 e</span></span><br><span class="line">    s = (r + a * e) % q  <span class="comment"># 计算 s</span></span><br><span class="line">    <span class="keyword">return</span> (e, s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">message, signature, A, g, p, q</span>):</span><br><span class="line">    e, s = signature</span><br><span class="line">    X_prime = (<span class="built_in">pow</span>(A, e, p) * <span class="built_in">pow</span>(g, s, p)) % p  <span class="comment"># 计算 X&#x27;</span></span><br><span class="line">    e_prime = hash_message(message, X_prime)  <span class="comment"># 计算 e&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> e_prime == e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例消息</span></span><br><span class="line">message = <span class="string">&quot;Hello, Schnorr!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名</span></span><br><span class="line">signature = sign(message, a, g, p, q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证签名</span></span><br><span class="line">is_valid = verify(message, signature, A, g, p, q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Signature is <span class="subst">&#123;<span class="string">&#x27;valid&#x27;</span> <span class="keyword">if</span> is_valid <span class="keyword">else</span> <span class="string">&#x27;invalid&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 椭圆曲线上的Schnorr签名</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 secp256k1 椭圆曲线参数</span></span><br><span class="line">p = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</span></span><br><span class="line">q = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span></span><br><span class="line">curve = EllipticCurve(GF(p), [<span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line">G = curve(<span class="number">0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</span>, <span class="number">0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">private_key = Integer(get_random_bytes(<span class="number">32</span>).<span class="built_in">hex</span>(), base=<span class="number">16</span>) % q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算公钥</span></span><br><span class="line">public_key = private_key * G</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_message</span>(<span class="params">message, x</span>):</span><br><span class="line">    combined = <span class="string">f&quot;<span class="subst">&#123;message&#125;</span><span class="subst">&#123;x&#125;</span>&quot;</span>.encode()</span><br><span class="line">    h = SHA256.new(combined).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(h, <span class="number">16</span>) % q</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">message, private_key, G, q</span>):</span><br><span class="line">    <span class="comment"># 选择随机数 r</span></span><br><span class="line">    r = Integer(get_random_bytes(<span class="number">32</span>).<span class="built_in">hex</span>(), base=<span class="number">16</span>) % q</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算点 R</span></span><br><span class="line">    R = r * G</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算挑战值 e</span></span><br><span class="line">    e = hash_message(message, R.xy()[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算签名分量 s</span></span><br><span class="line">    s = (r + e * private_key) % q</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (R.xy()[<span class="number">0</span>], s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">message, signature, public_key, G, q</span>):</span><br><span class="line">    x_R, s = signature</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算挑战值 e</span></span><br><span class="line">    e = hash_message(message, x_R)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算验证点 U</span></span><br><span class="line">    U = s * G - e * public_key</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查验证点的 x 坐标是否等于签名中的 x_R</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(U.xy()[<span class="number">0</span>]) == x_R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例消息</span></span><br><span class="line">message = <span class="string">&quot;Hello, Schnorr!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名</span></span><br><span class="line">signature = sign(message, private_key, G, q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证签名</span></span><br><span class="line">is_valid = verify(message, signature, public_key, G, q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Signature is <span class="subst">&#123;<span class="string">&#x27;valid&#x27;</span> <span class="keyword">if</span> is_valid <span class="keyword">else</span> <span class="string">&#x27;invalid&#x27;</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看出题目给出的Schnorr签名算法问题出在<code>compute_hash</code>函数上</p><p>正常的算法中<code>e = H(M||X)</code> where H() is the hash function</p><p>而题目给出的是<code>e = H(M|X)</code></p><p>所以当输入为全1时得到的hash为固定值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">separator = <span class="string">&quot;FF&quot;</span></span><br><span class="line">payload = <span class="string">&quot;7F7F7F&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Enter separator as a hex value (2 digits): &quot;</span>, separator.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 1 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 2 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 3 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 4 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 5 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 6 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 7 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Enter 3-letter word 8 as a hex value (6 digits): &quot;</span>,payload.encode().strip())</span><br><span class="line"></span><br><span class="line">TARGET = <span class="number">0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></span><br><span class="line">MESSAGE_OR_MASK = <span class="built_in">int</span>(<span class="string">&quot;7F7F7FFF&quot;</span> * <span class="number">8</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_hash</span>(<span class="params">target</span>):</span><br><span class="line">    hash_int = <span class="built_in">int</span>(hashlib.sha256(<span class="built_in">str</span>(target).encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> hash_int % n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_sig</span>(<span class="params">s, R_test</span>):</span><br><span class="line">    R_test_str = <span class="built_in">str</span>(R_test).strip(<span class="string">&quot;()&quot;</span>)</span><br><span class="line">    R_test_parts = [part.strip() <span class="keyword">for</span> part <span class="keyword">in</span> R_test_str.split(<span class="string">&quot;:&quot;</span>)]</span><br><span class="line">    xR = R_test_parts[<span class="number">0</span>]</span><br><span class="line">    yR = R_test_parts[<span class="number">1</span>]</span><br><span class="line">    sendxR = <span class="built_in">hex</span>(xR)[<span class="number">2</span>:]</span><br><span class="line">    sendyR = <span class="built_in">hex</span>(yR)[<span class="number">2</span>:]</span><br><span class="line">    send_s = <span class="built_in">hex</span>(s)[<span class="number">2</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;sendxR = &#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;sendyR = &#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;send_s = &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Enter the x-coordinate of signature R (in hex):&quot;</span>, sendxR)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Enter the y-coordinate of signature R (in hex):&quot;</span>, sendyR)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;EEnter signature s (in hex): &quot;</span>, send_s)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bruforce_signature</span>(<span class="params">P, G</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Brute-forcing to find a valid signature...&quot;</span>)</span><br><span class="line">    h = compute_hash(TARGET)</span><br><span class="line">    hP = h*P</span><br><span class="line">    s = secrets.randbelow(n)</span><br><span class="line">    sG = s*G</span><br><span class="line">    <span class="keyword">with</span> tqdm(total=<span class="number">0</span>, unit=<span class="string">&#x27; iterations&#x27;</span>, unit_scale=<span class="literal">True</span>) <span class="keyword">as</span> pbar:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            R_test = sG - hP</span><br><span class="line">            R_test_binary = <span class="built_in">int</span>(R_test.xy()[<span class="number">0</span>] + R_test.xy()[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (R_test_binary | MESSAGE_OR_MASK) == TARGET:</span><br><span class="line">                <span class="keyword">assert</span> s*G - h*P == R_test</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;found&quot;</span>)</span><br><span class="line">                verify_sig(s, R_test)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s = (s*<span class="number">2</span>) %n</span><br><span class="line">            sG = <span class="number">2</span>*sG</span><br><span class="line">            pbar.update(<span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">bruforce_signature(P, G)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WriteUP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论与编码课程实验</title>
      <link href="/post/1/"/>
      <url>/post/1/</url>
      
        <content type="html"><![CDATA[<h2 id="信源编码与信道编码综合实验">信源编码与信道编码综合实验</h2><p>实现Huffman编解码和Hamming码编解码</p><p>具体代码文件如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% a.m</span></span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&#x27;data.txt&#x27;</span>;</span><br><span class="line">[symbols, probabilities, selfinformation] = ProbabilityCalculation(file_path);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;信源符号：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(symbols);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;信源符号概率：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(probabilities);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;自信息量：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(selfinformation);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[symbols, probabilities, selfinformation]</span> = <span class="title">ProbabilityCalculation</span><span class="params">(filename)</span></span></span><br><span class="line">    <span class="comment">% 读取文件</span></span><br><span class="line">    fileID = fopen(filename, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    content = fscanf(fileID, <span class="string">&#x27;%c&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="comment">% 统计各个符号的出现次数</span></span><br><span class="line">    uniqueSymbols = unique(content);</span><br><span class="line">    symbolCounts = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(uniqueSymbols));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(uniqueSymbols)</span><br><span class="line">        symbolCounts(<span class="built_in">i</span>) = sum(content == uniqueSymbols(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 计算符号出现的概率</span></span><br><span class="line">    totalSymbols = sum(symbolCounts);</span><br><span class="line">    probabilities = symbolCounts / totalSymbols;</span><br><span class="line">    <span class="comment">% 计算自信息量</span></span><br><span class="line">    selfinformation = -<span class="built_in">log2</span>(probabilities);</span><br><span class="line">    <span class="comment">% 按照概率降序排列符号和概率</span></span><br><span class="line">    [sortedProbabilities, indices] = <span class="built_in">sort</span>(probabilities, <span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line">    symbols = uniqueSymbols(indices);</span><br><span class="line">    probabilities = sortedProbabilities;</span><br><span class="line">    <span class="comment">% 返回排序后的符号和对应的概率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% b.m</span></span><br><span class="line">[CODE, L_ave, yita, H] = HuffmanEncoding(probabilities);</span><br><span class="line"><span class="comment">% 展示输出码字、平均码长和编码效率</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;对应概率:&#x27;</span>,num2str(probabilities)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;对应码字:&#x27;</span>,CODE]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;平均码长:&#x27;</span>,num2str(L_ave)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;信源熵:&#x27;</span>,num2str(H)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;编码效率:&#x27;</span>,num2str(yita)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用新增函数进行编码并保存</span></span><br><span class="line">file_path = <span class="string">&#x27;data.txt&#x27;</span>;</span><br><span class="line">encodedFilePath = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line">decodedFilePath = <span class="string">&#x27;decoded_data.txt&#x27;</span>;</span><br><span class="line">EncodeAndSave(file_path, symbols, CODE, encodedFilePath);</span><br><span class="line">HuffmanDecoding(encodedFilePath, symbols, CODE, file_path, decodedFilePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Huffman码本对文件内容进行编码并保存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EncodeAndSave</span><span class="params">(file_path, symbols, CODE, encodedFilePath)</span></span></span><br><span class="line">    <span class="comment">% 读取原始文件内容</span></span><br><span class="line">    fileID = fopen(file_path, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    originalContent = fscanf(fileID, <span class="string">&#x27;%c&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="comment">% 初始化编码后的内容字符串</span></span><br><span class="line">    encodedContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">% 遍历原始内容的每个字符</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(originalContent)</span><br><span class="line">        <span class="comment">% 查找当前字符在symbols中的位置</span></span><br><span class="line">        symbolIndex = strfind(symbols, originalContent(<span class="built_in">i</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 如果找到，则根据索引从CODE中获取编码并添加到结果字符串</span></span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isempty</span>(symbolIndex)</span><br><span class="line">            encodedContent = strcat(encodedContent, CODE&#123;symbolIndex&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error([<span class="string">&#x27;未在符号集中找到字符：&#x27;</span>, originalContent(<span class="built_in">i</span>)]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 保存编码结果到新文件</span></span><br><span class="line">    fileID = fopen(encodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, encodedContent);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;编码内容已保存至：&#x27;</span>, encodedFilePath]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[CODE, L_ave, yita, H]</span> = <span class="title">HuffmanEncoding</span><span class="params">(probabilities)</span></span></span><br><span class="line">    p = probabilities;</span><br><span class="line">    N = <span class="built_in">length</span>(p);</span><br><span class="line">    <span class="comment">% 将概率排序并获得单步码字排序</span></span><br><span class="line">    code = strings(N<span class="number">-1</span>,N);   <span class="comment">% 初始化单步过程的码字</span></span><br><span class="line">    reflect = <span class="built_in">zeros</span>(N<span class="number">-1</span>,N);  <span class="comment">% 初始化位置对应向量</span></span><br><span class="line">    p_SD = p;                <span class="comment">% p_SD为每次得到的概率排序数组</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N<span class="number">-1</span>              <span class="comment">% i表示排序后第几个符号</span></span><br><span class="line">        M = <span class="built_in">length</span>(p_SD);</span><br><span class="line">        [p_SD,reflect(<span class="built_in">i</span>,<span class="number">1</span>:M)] = <span class="built_in">sort</span>(p_SD,<span class="string">&#x27;descend&#x27;</span>);<span class="comment">% 将概率从大到小进行排序</span></span><br><span class="line">        code(<span class="built_in">i</span>,M) = <span class="string">&#x27;1&#x27;</span>;                             <span class="comment">% 概率最小的是1</span></span><br><span class="line">        code(<span class="built_in">i</span>,M<span class="number">-1</span>) = <span class="string">&#x27;0&#x27;</span>;                           <span class="comment">% 概率第二小的暂且定义为0</span></span><br><span class="line">        p_SD(M<span class="number">-1</span>) = p_SD(M<span class="number">-1</span>) + p_SD(M);             <span class="comment">% 将最后两个概率相加</span></span><br><span class="line">        p_SD(M) = [];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 根据位置对应向量和单步过程的码字计算对应码字</span></span><br><span class="line">    CODE = strings(<span class="number">1</span>,N); <span class="comment">% 初始化对应码字</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        column = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">for</span> m = <span class="number">1</span>:N<span class="number">-1</span></span><br><span class="line">            [~, column] = <span class="built_in">find</span>(reflect(m,:) == column);</span><br><span class="line">            CODE(<span class="number">1</span>,<span class="built_in">i</span>) = strcat(CODE(<span class="number">1</span>,<span class="built_in">i</span>),code(m,column));</span><br><span class="line">            <span class="comment">% 将最小的两个概率映射成一个</span></span><br><span class="line">            <span class="keyword">if</span> column == N+<span class="number">1</span>-m</span><br><span class="line">                column = column<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    CODE = reverse(CODE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算平均码长</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">        L(<span class="built_in">i</span>) = <span class="built_in">size</span>(char(CODE(<span class="number">1</span>,<span class="built_in">i</span>)),<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    L_ave = sum(L.*p);</span><br><span class="line">    H = sum(-p.*<span class="built_in">log2</span>(p));</span><br><span class="line">    yita = H/L_ave; <span class="comment">% 计算编码效率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HuffmanDecoding</span><span class="params">(encodedFilePath, symbols, CODE, originalFilePath, decodedFilePath)</span></span></span><br><span class="line">    <span class="comment">% 读取编码后的文件内容</span></span><br><span class="line">    fileID = fopen(encodedFilePath, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    encodedContent = fscanf(fileID, <span class="string">&#x27;%s&#x27;</span>);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 构建逆码本</span></span><br><span class="line">    inv_CODE = cell(<span class="built_in">size</span>(CODE));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(CODE)</span><br><span class="line">        inv_CODE&#123;strcmp(CODE, CODE&#123;<span class="built_in">i</span>&#125;)&#125; = symbols(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 解码过程</span></span><br><span class="line">    decodedContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    currentCode = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(encodedContent)</span><br><span class="line">        currentCode = [currentCode, encodedContent(<span class="built_in">i</span>)];</span><br><span class="line">        foundSymbol = <span class="built_in">false</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">numel</span>(CODE)</span><br><span class="line">            <span class="keyword">if</span> strcmp(currentCode, CODE&#123;<span class="built_in">j</span>&#125;)</span><br><span class="line">                decodedContent = strcat(decodedContent, inv_CODE&#123;<span class="built_in">j</span>&#125;);</span><br><span class="line">                currentCode = <span class="string">&#x27;&#x27;</span>; <span class="comment">% 重置当前码，开始下一个码的匹配</span></span><br><span class="line">                foundSymbol = <span class="built_in">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 保存解码结果到新文件</span></span><br><span class="line">    fileID = fopen(decodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, decodedContent);</span><br><span class="line">    fclose(fileID);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;解码内容已保存至：&#x27;</span>, decodedFilePath]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 与原始文件进行对比，计算误码率</span></span><br><span class="line">    originalFileContent = fileread(originalFilePath);</span><br><span class="line">    errors = sum(strcmp(decodedContent, originalFileContent) == <span class="number">0</span>);</span><br><span class="line">    totalChars = <span class="built_in">numel</span>(decodedContent);</span><br><span class="line">    errorRate = errors / totalChars;</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;误码率:&#x27;</span>, num2str(errorRate)]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% c.m</span></span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置参数</span></span><br><span class="line">n = <span class="number">7</span>;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">file_path = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取文件内容</span></span><br><span class="line">fid = fopen(file_path, <span class="string">&#x27;rt&#x27;</span>); <span class="comment">% &#x27;rt&#x27; 表示读取文本文件</span></span><br><span class="line">dataStr = fscanf(fid, <span class="string">&#x27;%c&#x27;</span>); <span class="comment">% 读取全部字符</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% 初始化二进制向量</span></span><br><span class="line">data_bits = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(dataStr));</span><br><span class="line"><span class="comment">% 遍历字符串，转换字符到比特</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(dataStr)</span><br><span class="line">    <span class="keyword">if</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;1&#x27;</span> <span class="comment">% 字符&#x27;1&#x27;转换为二进制1</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elseif</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;0&#x27;</span> <span class="comment">% 字符&#x27;0&#x27;转换为二进制0</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码解码</span></span><br><span class="line">[Encode0, Encode_str] = HammingEncoding(data_bits, n, k);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设定错误转移概率的变量范围</span></span><br><span class="line">berRange = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.1</span>; <span class="comment">% 误码率从0到10%，以0.5%为步长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化曲线数据</span></span><br><span class="line">avgBitErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(berRange));</span><br><span class="line">blockErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(berRange));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 遍历每个误码率</span></span><br><span class="line"><span class="keyword">for</span> w = <span class="number">1</span>:<span class="built_in">length</span>(berRange)</span><br><span class="line">    ber = berRange(w);</span><br><span class="line">    [Encode] = simulateBSC(Encode0, ber);</span><br><span class="line">    [Decode, Decode_str] = HammingDecoding(Encode, n, k);    </span><br><span class="line">    <span class="comment">% 计算错误位置</span></span><br><span class="line">    original_bits = data_bits; <span class="comment">% 从原始数据转换而来</span></span><br><span class="line">    decoded_bits = Decode;     <span class="comment">% 从decoded_str转换而来，确保长度一致</span></span><br><span class="line">    errors_positions = [];     <span class="comment">% 初始化错误位置列表</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(original_bits)</span><br><span class="line">        <span class="keyword">if</span> original_bits(<span class="built_in">i</span>) ~= decoded_bits(<span class="built_in">i</span>)</span><br><span class="line">            errors_positions = [errors_positions, <span class="built_in">i</span>]; <span class="comment">% 记录错误位置</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    total_errors = <span class="built_in">length</span>(errors_positions);</span><br><span class="line">    total_bits = <span class="built_in">length</span>(original_bits);</span><br><span class="line">    <span class="comment">% 计算平均误比特率</span></span><br><span class="line">    average_bit_error_rate = total_errors / total_bits;</span><br><span class="line">    <span class="comment">% 计算平均误比特率</span></span><br><span class="line">    block_error_rate = <span class="number">1</span> - (<span class="number">1</span> - average_bit_error_rate)^n;</span><br><span class="line">          </span><br><span class="line">    <span class="comment">% 记录数据</span></span><br><span class="line">    avgBitErrorRate(w) = average_bit_error_rate;</span><br><span class="line">    blockErrorRate(w) = block_error_rate;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制曲线图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制曲线图</span></span><br><span class="line"><span class="built_in">plot</span>(berRange, avgBitErrorRate, <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;Marker&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">% plot(berRange, blockErrorRate, &#x27;b-&#x27;, &#x27;LineWidth&#x27;, 2, &#x27;Marker&#x27;, &#x27;.&#x27;, &#x27;MarkerSize&#x27;, 6);</span></span><br><span class="line"><span class="comment">% 添加标题和轴标签</span></span><br><span class="line">title(<span class="string">&#x27;平均误比特率与二进制对称信道错误转移概率的关系&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;二进制对称信道错误转移概率 (BER)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;平均误比特率&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置坐标轴范围和精度</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">0.1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 可以选择设置网格线</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成矩阵和校验矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[G, H]</span> = <span class="title">hamming_code_matrices</span><span class="params">(n, k)</span></span></span><br><span class="line">    [H, G, ~, ~] = hammgen(n-k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[encoded_stream, encode_str]</span> = <span class="title">HammingEncoding</span><span class="params">(data_bits, n, k)</span></span></span><br><span class="line">    <span class="comment">% 获取生成矩阵</span></span><br><span class="line">    [G, ~] = hamming_code_matrices(n, k);</span><br><span class="line">    <span class="comment">% disp(G);</span></span><br><span class="line">    <span class="comment">% 初始化编码结果的存储</span></span><br><span class="line">    encoded_stream = [];</span><br><span class="line">    <span class="comment">% 处理整个比特流</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data_bits) &gt;= k</span><br><span class="line">        <span class="comment">% 对当前k位数据进行编码</span></span><br><span class="line">        group = data_bits(<span class="number">1</span>:k);</span><br><span class="line">        <span class="comment">% 对当前组进行编码</span></span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>); </span><br><span class="line">        <span class="comment">% 累积编码结果</span></span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group]; </span><br><span class="line">        <span class="comment">% 移动到下一个k位数据</span></span><br><span class="line">        data_bits = data_bits(k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 处理剩余不足k位的数据（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(data_bits)</span><br><span class="line">        <span class="comment">% 补齐到k位</span></span><br><span class="line">        data_bits(<span class="keyword">end</span>+<span class="number">1</span>:k) = <span class="built_in">zeros</span>(<span class="number">1</span>, k - <span class="built_in">length</span>(data_bits));</span><br><span class="line">        group = data_bits;</span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>);</span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group];</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 显示最终编码后的比特流</span></span><br><span class="line">    encode_str = num2str(encoded_stream);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 解码（有纠错）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[decoded_data, decoded_str]</span> = <span class="title">HammingDecoding</span><span class="params">(encoded_stream, n, k)</span>    </span></span><br><span class="line">    [~, H] = hamming_code_matrices(n, k);     </span><br><span class="line">    decoded_data = [];    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(encoded_stream)&gt;=n</span><br><span class="line">        encoded_group = encoded_stream(<span class="number">1</span>:n);        </span><br><span class="line">        encoded_stream = encoded_stream(n+<span class="number">1</span>:<span class="keyword">end</span>);        </span><br><span class="line">        syndrome = <span class="built_in">mod</span>(encoded_group * H&#x27;, <span class="number">2</span>);</span><br><span class="line">        mat1 = <span class="built_in">eye</span>(n);</span><br><span class="line">        errvec = mat1*H&#x27;;</span><br><span class="line">        <span class="comment">% 如果syndrome非零，则存在错误</span></span><br><span class="line">        <span class="keyword">if</span> any(syndrome)            </span><br><span class="line">            <span class="keyword">for</span> index=<span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span>(syndrome==errvec(index,:))</span><br><span class="line">                    encoded_group = <span class="built_in">mod</span>(encoded_group+mat1(index,:),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>             </span><br><span class="line">        decoded_group = encoded_group(n-k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">        <span class="comment">% 累积解码数据，不忽略任何编码组</span></span><br><span class="line">        decoded_data = [decoded_data, decoded_group];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    decoded_data = [decoded_data, encoded_stream];</span><br><span class="line">    <span class="comment">%disp([&#x27;总纠错数：&#x27;,corrected_errors]);</span></span><br><span class="line">    <span class="comment">% 转换为字符串</span></span><br><span class="line">    decoded_str = num2str(decoded_data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 二进制对称信道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[transmittedStream]</span> = <span class="title">simulateBSC</span><span class="params">(encodedStream, ber)</span></span></span><br><span class="line">    <span class="comment">% 模拟二进制对称信道传输编码后的数据流</span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">%   encodedStream: 编码后的二进制数据流，1xN的二进制数组</span></span><br><span class="line">    <span class="comment">%   ber: 误码率，一个介于0和1之间的标量</span></span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">%   transmittedStream: 通过BSC传输后的数据流</span></span><br><span class="line">    <span class="comment">% 获取数据流的长度</span></span><br><span class="line">    streamLength = <span class="built_in">length</span>(encodedStream);</span><br><span class="line">    <span class="comment">% 生成随机错误分布，1表示发生错误，0表示无错误</span></span><br><span class="line">    errorVector = <span class="built_in">rand</span>(streamLength, <span class="number">1</span>) &lt; ber;</span><br><span class="line">    <span class="comment">% 应用错误到数据流</span></span><br><span class="line">    transmittedStream = encodedStream;</span><br><span class="line">    transmittedStream(errorVector == <span class="number">1</span>) = xor(encodedStream(errorVector == <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 返回经过错误注入的传输数据流</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% d.m</span></span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置参数</span></span><br><span class="line">n = <span class="number">7</span>;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">file_path = <span class="string">&#x27;encoded_data.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取文件内容</span></span><br><span class="line">fid = fopen(file_path, <span class="string">&#x27;rt&#x27;</span>); <span class="comment">% &#x27;rt&#x27; 表示读取文本文件</span></span><br><span class="line">dataStr = fscanf(fid, <span class="string">&#x27;%c&#x27;</span>);  <span class="comment">% 读取全部字符</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% 初始化二进制向量</span></span><br><span class="line">data_bits = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(dataStr));</span><br><span class="line"><span class="comment">% 遍历字符串，转换字符到比特</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(dataStr)</span><br><span class="line">    <span class="keyword">if</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;1&#x27;</span> <span class="comment">% 字符&#x27;1&#x27;转换为二进制1</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elseif</span> dataStr(<span class="built_in">i</span>) == <span class="string">&#x27;0&#x27;</span> <span class="comment">% 字符&#x27;0&#x27;转换为二进制0</span></span><br><span class="line">        data_bits(<span class="built_in">i</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码解码</span></span><br><span class="line">[Encode, Encode_str] = HammingEncoding(data_bits, n, k);</span><br><span class="line">ber = <span class="number">0.001</span>; <span class="comment">% 设定误码率为0.1%</span></span><br><span class="line">[G, H] = hamming_code_matrices(n, k);</span><br><span class="line">[Encode] = simulateBSC(Encode, ber);</span><br><span class="line">[Decode, Decode_str] = HammingDecoding(Encode, n, k);</span><br><span class="line">decodedFilePath = <span class="string">&#x27;decoded.txt&#x27;</span>;</span><br><span class="line">fileID = fopen(decodedFilePath, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;%s&#x27;</span>, Decode_str);</span><br><span class="line">fclose(fileID);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;解码内容已保存至：&#x27;</span>, decodedFilePath]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算错误位置</span></span><br><span class="line">original_bits = data_bits; <span class="comment">% 从原始数据转换而来</span></span><br><span class="line">decoded_bits = Decode;     <span class="comment">% 从decoded_str转换而来，确保长度一致</span></span><br><span class="line">errors_positions = [];     <span class="comment">% 初始化错误位置列表</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(original_bits)</span><br><span class="line">    <span class="keyword">if</span> original_bits(<span class="built_in">i</span>) ~= decoded_bits(<span class="built_in">i</span>)</span><br><span class="line">        errors_positions = [errors_positions, <span class="built_in">i</span>]; <span class="comment">% 记录错误位置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(errors_positions)</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span>, num2str(<span class="built_in">i</span>),<span class="string">&#x27;个错误位置 &#x27;</span>, <span class="string">&#x27;: &#x27;</span>, num2str(errors_positions(<span class="built_in">i</span>))]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 平均误比特率和误组率</span></span><br><span class="line">total_errors = <span class="built_in">length</span>(errors_positions);</span><br><span class="line">total_bits = <span class="built_in">length</span>(original_bits);</span><br><span class="line">average_bit_error_rate = total_errors / total_bits;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;平均误比特率: &#x27;</span>, num2str(average_bit_error_rate)]);</span><br><span class="line">block_error_rate = <span class="number">1</span> - (<span class="number">1</span> - average_bit_error_rate)^n;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;误组率: &#x27;</span>, num2str(block_error_rate)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成矩阵和校验矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[G, H]</span> = <span class="title">hamming_code_matrices</span><span class="params">(n, k)</span></span></span><br><span class="line">    [H, G, ~, ~] = hammgen(n-k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[encoded_stream, encode_str]</span> = <span class="title">HammingEncoding</span><span class="params">(data_bits, n, k)</span></span></span><br><span class="line">    <span class="comment">% 获取生成矩阵</span></span><br><span class="line">    [G, ~] = hamming_code_matrices(n, k);</span><br><span class="line">    <span class="comment">% disp(G);</span></span><br><span class="line">    <span class="comment">% 初始化编码结果的存储</span></span><br><span class="line">    encoded_stream = [];</span><br><span class="line">    <span class="comment">% 处理整个比特流</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data_bits) &gt;= k</span><br><span class="line">        <span class="comment">% 对当前k位数据进行编码</span></span><br><span class="line">        group = data_bits(<span class="number">1</span>:k);</span><br><span class="line">        <span class="comment">% 对当前组进行编码</span></span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>); </span><br><span class="line">        <span class="comment">% 累积编码结果</span></span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group]; </span><br><span class="line">        <span class="comment">% 移动到下一个k位数据</span></span><br><span class="line">        data_bits = data_bits(k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 处理剩余不足k位的数据（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(data_bits)</span><br><span class="line">        <span class="comment">% 补齐到k位</span></span><br><span class="line">        data_bits(<span class="keyword">end</span>+<span class="number">1</span>:k) = <span class="built_in">zeros</span>(<span class="number">1</span>, k - <span class="built_in">length</span>(data_bits));</span><br><span class="line">        group = data_bits;</span><br><span class="line">        encoded_group = <span class="built_in">mod</span>(group * G, <span class="number">2</span>);</span><br><span class="line">        encoded_stream = [encoded_stream, encoded_group];</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    <span class="comment">% 显示最终编码后的比特流</span></span><br><span class="line">    encode_str = num2str(encoded_stream);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 解码（有纠错）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[decoded_data, decoded_str]</span> = <span class="title">HammingDecoding</span><span class="params">(encoded_stream, n, k)</span>    </span></span><br><span class="line">    [~, H] = hamming_code_matrices(n, k);     </span><br><span class="line">    decoded_data = [];    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(encoded_stream)&gt;=n</span><br><span class="line">        encoded_group = encoded_stream(<span class="number">1</span>:n);        </span><br><span class="line">        encoded_stream = encoded_stream(n+<span class="number">1</span>:<span class="keyword">end</span>);        </span><br><span class="line">        syndrome = <span class="built_in">mod</span>(encoded_group * H&#x27;, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">disp</span>(syndrome);</span><br><span class="line">        mat1 = <span class="built_in">eye</span>(n);</span><br><span class="line">        errvec = mat1*H&#x27;;</span><br><span class="line">        <span class="comment">% 如果syndrome非零，则存在错误</span></span><br><span class="line">        <span class="keyword">if</span> any(syndrome)            </span><br><span class="line">            <span class="keyword">for</span> index=<span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span>(syndrome==errvec(index,:))</span><br><span class="line">                    encoded_group = <span class="built_in">mod</span>(encoded_group+mat1(index,:),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>             </span><br><span class="line">        decoded_group = encoded_group(n-k+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">        <span class="comment">% 累积解码数据，不忽略任何编码组</span></span><br><span class="line">        decoded_data = [decoded_data, decoded_group];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    decoded_data = [decoded_data, encoded_stream];</span><br><span class="line">    <span class="comment">%disp([&#x27;总纠错数：&#x27;,corrected_errors]);</span></span><br><span class="line">    <span class="comment">% 转换为字符串</span></span><br><span class="line">    decoded_str = num2str(decoded_data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 二进制对称信道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[transmittedStream]</span> = <span class="title">simulateBSC</span><span class="params">(encodedStream, ber)</span></span></span><br><span class="line">    <span class="comment">% 模拟二进制对称信道传输编码后的数据流</span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">%   encodedStream: 编码后的二进制数据流，1xN的二进制数组</span></span><br><span class="line">    <span class="comment">%   ber: 误码率，一个介于0和1之间的标量</span></span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">%   transmittedStream: 通过BSC传输后的数据流</span></span><br><span class="line">    <span class="comment">% 获取数据流的长度</span></span><br><span class="line">    streamLength = <span class="built_in">length</span>(encodedStream);</span><br><span class="line">    <span class="comment">% 生成随机错误分布，1表示发生错误，0表示无错误</span></span><br><span class="line">    errorVector = <span class="built_in">rand</span>(streamLength, <span class="number">1</span>) &lt; ber;</span><br><span class="line">    <span class="comment">% 应用错误到数据流</span></span><br><span class="line">    transmittedStream = encodedStream;</span><br><span class="line">    transmittedStream(errorVector == <span class="number">1</span>) = xor(encodedStream(errorVector == <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 返回经过错误注入的传输数据流</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
